version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:19.0) Gecko/20100101 Firefox/19.0
author=tamara
charset=ISO-8859-1
csum=a little more refactoring
ctime=1354778568
host=71.63.215.130
name=Technology.ExtendRubyStringToImplementTitleCase
rev=9
targets=Technology.ExtendRubyStringToImplementTitleCase,Technology.StopWords,Technology.OpenClass,Technology.MonkeyPatching,Technology.Ruby,Technology.IncludeMe,Category.HowTos
text=[[#excerpt]]%0aOn the ruby-talk list, someone was trying to implement method to convert a string to title case, using [[stop words]] that would not get capitalized.%0a%0a'''Update:''' using Modules!%0a%0a[[#excerptend]]%0a%0aThe original version of this how-to talked about using the [[OpenClass| ''Open CLass'' ]] technique (aka [[MonkeyPatching | "Monkeypatching"]]) for modifying an existing class. While Open Classing is a viable technique, it is largely frowned upon for the possibility of injecting or causing errors which may be hard to find.%0a%0aThe book [[ ''Metaprogramming in Ruby'' -> http://wiki.tamaratemple.com/Technology/BookReviewMetaprogrammingInRuby]] makes it clear that one should '''Think in Modules'''. So, I decided to rewrite this how-to utilizing Ruby modules instead of the Open Class.%0a%0aSo let's add our titlecase method again, only using a Module.%0a%0a!! Creating the Module%0a%0aRefactoring the end version of the method, we've got it down to a single chain in both methods, destructive and duplicative.%0a%0a(:source lang=ruby linenum header="My String Extensions":)%0amodule MyStringExtensions%0a%0a  # destructive version%0a  def titlecase!(stopwords=%25w{and or a an the of for by})%0a    self.gsub!(/\w+/) do |w| %0a      stopwords.map(&:downcase).include?(w.downcase!) ? w : w.capitalize%0a    end.gsub!(/^\w/,&:capitalize)%0a  end%0a%0a  # duplicating version%0a  def titlecase(stopwords=%25w{and or a an the of for by})%0a    dup.titlecase!(stopwords)%0a  end%0a    %0aend%0a(:sourceend:)%0a%0aNow, we'll include the module into the String class via a @@send@@:%0a%0a(:source lang=ruby linenum:)%0aString.send(:include, MyStringExtensions)%0a(:sourceend:)%0a%0aAnd, we'll give it a go:%0a%0a(:source lang=text:)%0airb(main):140:0> p = 'now is the winter of our discount tent'%0a"now is the winter of our discount tent"%0airb(main):141:0> p.titlecase%0a"Now Is the Winter of Our Discount Tent"%0airb(main):142:0> p # UNCHANGED!%0a"now is the winter of our discount tent"%0airb(main):143:0> p.titlecase!%0a"Now Is the Winter of Our Discount Tent"%0airb(main):144:0> p # CHANGED!%0a"Now Is the Winter of Our Discount Tent"%0airb(main):145:0> %0a(:sourceend:)%0a%0a%0a%0a%0a%0a!! The Open Class way%0a%0aIn [[Ruby]], it's very simple to add a new method to a class. All you have to do is re-open the class:%0a%0a(:source lang=ruby linenum tabwidth=4 header="titlecase.rb":)%0a=begin%0a  %0a   In ruby, the String class includes methods for converting to upper%0a   and lower case (upcase and downcase). It doesn't seem to include the%0a   conversion to title case, however, much less the opportunity to%0a   include stop words (words which will not be converted).%0a%0a   This is a quick example to show how to add a method to String that%0a   will do this.%0a%0a=end %0a%0aclass String%0a%0a=begin%0a%0a   The titlecase method will return a string where the words in phrase%0a   are converted to capitalized words, unless a word is in the list of%0a   stopwords. The first word will be capitalized regardless of whether%0a   it's in the stopword list or not.%0a%0a   You can pass in your own list of stopwords as well.%0a%0a=end%0a  def titlecase(stopwords=%25w{and or and/or a an the of})%0a    t = self.split.each do |w|%0a      w[0]=w[0].upcase unless stopwords.include?(w)%0a      w%0a    end.join(" ")%0a    t[0]=t[0].upcase # force first word to upper case, regardless%0a    t # return the full string%0a  end%0aend%0a(:sourceend:)%0a%0aThen:%0a%0a(:source lang=ruby:)%0arequire 'titlecase'%0a%0a"the quick brown fox or a rabbit in the hen house of love and his doggie".titlecase%0a# => "The Quick Brown Fox or a Rabbit In the Hen House of Love and His Doggie" %0a%0a=begin%0a%0a   Passing in our own list of stop words:%0a   Note that the first character of the string is **always** up-cased.%0a%0a=end%0a"the quick and the dead".titlecase(%25w{the dead})%0a# => "The Quick And the dead" %0a%0a(:sourceend:)%0a%0a%0a!!! Refactor 1 - use gsub instead of split%0a%0aAnd another way to implement the method:%0a%0a(:source lang=ruby linenum:)%0a  def titlecase(stopwords=%25w{and or a an the of})%0a    t = self.gsub(/\w+/) do |w|%0a      stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a    end%0a    t[0]=t[0].upcase%0a    t # return the full string%0a  end%0a(:sourceend:)%0a%0a!!! Refactor 2 - without intermediate assignment%0a%0aAnd we'll get it down to 3 lines:%0a%0a(:source lang=ruby:)%0adef titlecase(stopwords=%25w{and or a an the of})%0a  self.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a  self[0]=self[0].upcase%0a  self%0aend%0a(:sourceend:)%0a%0a!!! Refactor 3 - a more complete implementation%0a%0aThis version offers a destructive (!-method) and non-desctructive methods. It also more correctly will convert the stop words to lowercase on comparison, as well as converting them in the substitution.%0a%0a(:source lang=ruby linenum tabwidth=4 header="destructive and non-destructive versions":)%0aclass String # Open Class%0a%0a  # destructive version%0a  def titlecase!(stopwords=%25w{and or a an the of})%0a    self.gsub!(/\w+/){|w| stopwords.include?(w.downcase) ? w.downcase%0a      : w.capitalize}%0a    self[0]=self[0].upcase%0a    self%0a  end%0a%0a  # duplicating version%0a  def titlecase(stopwords=%25w{and or a an the of})%0a    t = self.dup%0a    t.titlecase!(stopwords)%0a  end%0a%0aend%0a%0a# assign a string%0ap = "the and, without further adieu, some international incident or other caused us to pray"%0a# => "the and, without further adieu, some international incident or other caused us to pray" %0a%0a# Non-destructive form:%0ap.titlecase%0a# => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a%0a# unchanged from original%0ap%0a# => "the and, without further adieu, some international incident or other caused us to pray" %0a%0a%0a# destructive form:%0ap.titlecase!%0a# => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a%0a# changed original%0ap%0a# => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a(:sourceend:)%0a%0a>>comment%3c%3c%0aSummary:A example of extending a Ruby class, and implementing a useful method besides.%0aParent:(Technology.)Ruby%0aIncludeMe:[[(Technology.)Ruby]]%0aCategories:[[!HowTos]]%0aTags: ruby, classes, string, titlecase%0a(:tags-hide ruby, classes, string, titlecase :)%0a>>%3c%3c%0a
time=1364163629
author:1364163629=tamara
csum:1364163629=a little more refactoring
diff:1364163629:1364163040:minor=16,17c16,17%0a%3c Refactoring the end version of the method, we've got it down to a single chain in both methods, destructive and duplicative.%0a%3c %0a---%0a> We'll skip the refactoring that went on in the first version, and cut right to the end version.%0a> %0a24c24%0a%3c       stopwords.map(&:downcase).include?(w.downcase!) ? w : w.capitalize%0a---%0a>       stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a36c36%0a%3c Now, we'll include the module into the String class via a @@send@@:%0a---%0a> Now, we'll add the module to the String class via a send:%0a
host:1364163629=71.63.215.130
author:1364163040=tamara
csum:1364163040=clean up, a little refactoring
diff:1364163040:1354783470:=3,5d2%0a%3c %0a%3c '''Update:''' using Modules!%0a%3c %0a8,25c5,40%0a%3c The original version of this how-to talked about using the [[OpenClass| ''Open CLass'' ]] technique (aka [[MonkeyPatching | "Monkeypatching"]]) for modifying an existing class. While Open Classing is a viable technique, it is largely frowned upon for the possibility of injecting or causing errors which may be hard to find.%0a%3c %0a%3c The book [[ ''Metaprogramming in Ruby'' -> http://wiki.tamaratemple.com/Technology/BookReviewMetaprogrammingInRuby]] makes it clear that one should '''Think in Modules'''. So, I decided to rewrite this how-to utilizing Ruby modules instead of the Open Class.%0a%3c %0a%3c So let's add our titlecase method again, only using a Module.%0a%3c %0a%3c !! Creating the Module%0a%3c %0a%3c We'll skip the refactoring that went on in the first version, and cut right to the end version.%0a%3c %0a%3c (:source lang=ruby linenum header="My String Extensions":)%0a%3c module MyStringExtensions%0a%3c %0a%3c   # destructive version%0a%3c   def titlecase!(stopwords=%25w{and or a an the of for by})%0a%3c     self.gsub!(/\w+/) do |w| %0a%3c       stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a%3c     end.gsub!(/^\w/,&:capitalize)%0a---%0a> !! Adding a method to an existing class%0a> %0a> In [[Ruby]], it's very simple to add a new method to a class. All you have to do is re-open the class:%0a> %0a> (:source lang=ruby linenum tabwidth=4 header="titlecase.rb":)%0a> =begin%0a>   %0a>    In ruby, the String class includes methods for converting to upper%0a>    and lower case (upcase and downcase). It doesn't seem to include the%0a>    conversion to title case, however, much less the opportunity to%0a>    include stop words (words which will not be converted).%0a> %0a>    This is a quick example to show how to add a method to String that%0a>    will do this.%0a> %0a> =end %0a> %0a> class String%0a> %0a> =begin%0a> %0a>    The titlecase method will return a string where the words in phrase%0a>    are converted to capitalized words, unless a word is in the list of%0a>    stopwords. The first word will be capitalized regardless of whether%0a>    it's in the stopword list or not.%0a> %0a>    You can pass in your own list of stopwords as well.%0a> %0a> =end%0a>   def titlecase(stopwords=%25w{and or and/or a an the of})%0a>     t = self.split.each do |w|%0a>       w[0]=w[0].upcase unless stopwords.include?(w)%0a>       w%0a>     end.join(" ")%0a>     t[0]=t[0].upcase # force first word to upper case, regardless%0a>     t # return the full string%0a27,32d41%0a%3c %0a%3c   # duplicating version%0a%3c   def titlecase(stopwords=%25w{and or a an the of for by})%0a%3c     dup.titlecase!(stopwords)%0a%3c   end%0a%3c     %0a36,39c45,61%0a%3c Now, we'll add the module to the String class via a send:%0a%3c %0a%3c (:source lang=ruby linenum:)%0a%3c String.send(:include, MyStringExtensions)%0a---%0a> Then:%0a> %0a> (:source lang=ruby:)%0a> require 'titlecase'%0a> %0a> "the quick brown fox or a rabbit in the hen house of love and his doggie".titlecase%0a> # => "The Quick Brown Fox or a Rabbit In the Hen House of Love and His Doggie" %0a> %0a> =begin%0a> %0a>    Passing in our own list of stop words:%0a>    Note that the first character of the string is **always** up-cased.%0a> %0a> =end%0a> "the quick and the dead".titlecase(%25w{the dead})%0a> # => "The Quick And the dead" %0a> %0a42,55c64,76%0a%3c And, we'll give it a go:%0a%3c %0a%3c (:source lang=text:)%0a%3c irb(main):140:0> p = 'now is the winter of our discount tent'%0a%3c "now is the winter of our discount tent"%0a%3c irb(main):141:0> p.titlecase%0a%3c "Now Is the Winter of Our Discount Tent"%0a%3c irb(main):142:0> p # UNCHANGED!%0a%3c "now is the winter of our discount tent"%0a%3c irb(main):143:0> p.titlecase!%0a%3c "Now Is the Winter of Our Discount Tent"%0a%3c irb(main):144:0> p # CHANGED!%0a%3c "Now Is the Winter of Our Discount Tent"%0a%3c irb(main):145:0> %0a---%0a> %0a> !! Refactor 1 - use gsub instead of split%0a> %0a> And another way to implement the method:%0a> %0a> (:source lang=ruby linenum:)%0a>   def titlecase(stopwords=%25w{and or a an the of})%0a>     t = self.gsub(/\w+/) do |w|%0a>       stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a>     end%0a>     t[0]=t[0].upcase%0a>     t # return the full string%0a>   end%0a58,103c79,82%0a%3c %0a%3c %0a%3c %0a%3c %0a%3c !! The Open Class way%0a%3c %0a%3c In [[Ruby]], it's very simple to add a new method to a class. All you have to do is re-open the class:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="titlecase.rb":)%0a%3c =begin%0a%3c   %0a%3c    In ruby, the String class includes methods for converting to upper%0a%3c    and lower case (upcase and downcase). It doesn't seem to include the%0a%3c    conversion to title case, however, much less the opportunity to%0a%3c    include stop words (words which will not be converted).%0a%3c %0a%3c    This is a quick example to show how to add a method to String that%0a%3c    will do this.%0a%3c %0a%3c =end %0a%3c %0a%3c class String%0a%3c %0a%3c =begin%0a%3c %0a%3c    The titlecase method will return a string where the words in phrase%0a%3c    are converted to capitalized words, unless a word is in the list of%0a%3c    stopwords. The first word will be capitalized regardless of whether%0a%3c    it's in the stopword list or not.%0a%3c %0a%3c    You can pass in your own list of stopwords as well.%0a%3c %0a%3c =end%0a%3c   def titlecase(stopwords=%25w{and or and/or a an the of})%0a%3c     t = self.split.each do |w|%0a%3c       w[0]=w[0].upcase unless stopwords.include?(w)%0a%3c       w%0a%3c     end.join(" ")%0a%3c     t[0]=t[0].upcase # force first word to upper case, regardless%0a%3c     t # return the full string%0a%3c   end%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c Then:%0a%3c %0a---%0a> !! Refactor 2 - without intermediate assignment%0a> %0a> And we'll get it down to 3 lines:%0a> %0a105,118c84,88%0a%3c require 'titlecase'%0a%3c %0a%3c "the quick brown fox or a rabbit in the hen house of love and his doggie".titlecase%0a%3c # => "The Quick Brown Fox or a Rabbit In the Hen House of Love and His Doggie" %0a%3c %0a%3c =begin%0a%3c %0a%3c    Passing in our own list of stop words:%0a%3c    Note that the first character of the string is **always** up-cased.%0a%3c %0a%3c =end%0a%3c "the quick and the dead".titlecase(%25w{the dead})%0a%3c # => "The Quick And the dead" %0a%3c %0a---%0a> def titlecase(stopwords=%25w{and or a an the of})%0a>   self.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a>   self[0]=self[0].upcase!%0a>   self%0a> end%0a121,149c91,92%0a%3c %0a%3c !!! Refactor 1 - use gsub instead of split%0a%3c %0a%3c And another way to implement the method:%0a%3c %0a%3c (:source lang=ruby linenum:)%0a%3c   def titlecase(stopwords=%25w{and or a an the of})%0a%3c     t = self.gsub(/\w+/) do |w|%0a%3c       stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a%3c     end%0a%3c     t[0]=t[0].upcase%0a%3c     t # return the full string%0a%3c   end%0a%3c (:sourceend:)%0a%3c %0a%3c !!! Refactor 2 - without intermediate assignment%0a%3c %0a%3c And we'll get it down to 3 lines:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c def titlecase(stopwords=%25w{and or a an the of})%0a%3c   self.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a%3c   self[0]=self[0].upcase%0a%3c   self%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c !!! Refactor 3 - a more complete implementation%0a%3c %0a---%0a> !! Refactor 3 - a more complete implementation%0a> %0a153,168c96,100%0a%3c class String # Open Class%0a%3c %0a%3c   # destructive version%0a%3c   def titlecase!(stopwords=%25w{and or a an the of})%0a%3c     self.gsub!(/\w+/){|w| stopwords.include?(w.downcase) ? w.downcase%0a%3c       : w.capitalize}%0a%3c     self[0]=self[0].upcase%0a%3c     self%0a%3c   end%0a%3c %0a%3c   # duplicating version%0a%3c   def titlecase(stopwords=%25w{and or a an the of})%0a%3c     t = self.dup%0a%3c     t.titlecase!(stopwords)%0a%3c   end%0a%3c %0a---%0a> def titlecase!(stopwords=%25w{and or a an the of})%0a>   self.gsub!(/\w+/){|w| stopwords.include?(w.downcase) ? w.downcase%0a>     : w.capitalize}%0a>   self[0]=self[0].upcase!%0a>   self%0a170c102,106%0a%3c %0a---%0a> def titlecase(stopwords=%25w{and or a an the of})%0a>   t = self.dup%0a>   t.titlecase!(stopwords)%0a> end%0a> %0a200c136%0a%3c >>%3c%3c%0a---%0a> >>%3c%3c%0a\ No newline at end of file%0a
host:1364163040=71.63.215.130
author:1354783470=tamara
csum:1354783470=add destructive methods on 2nd refactor
diff:1354783470:1354782934:=65,66d64%0a%3c !! Refactor 1 - use gsub instead of split%0a%3c %0a79,80c77%0a%3c !! Refactor 2 - without intermediate assignment%0a%3c %0a---%0a> %0a85,86c82,83%0a%3c   self.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a%3c   self[0]=self[0].upcase!%0a---%0a>   self.gsub(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a>   self[0]=self[0].upcase%0a91,93c88%0a%3c !! Refactor 3 - a more complete implementation%0a%3c %0a%3c This version offers a destructive (!-method) and non-desctructive methods. It also more correctly will convert the stop words to lowercase on comparison, as well as converting them in the substitution.%0a---%0a> Perhaps a way to implement in parallel with the upcase and upcase! methods:%0a
host:1354783470=71.63.215.130
author:1354782934=tamara
csum:1354782934=get rid of and/or contraption, pass stopwords
diff:1354782934:1354782748:=68c68%0a%3c   def titlecase(stopwords=%25w{and or a an the of})%0a---%0a>   def titlecase(stopwords=%25w{and or and/or a an the of})%0a91c91%0a%3c def titlecase!(stopwords=%25w{and or a an the of})%0a---%0a> def titlecase!(stopwords=%25w{and or and/or a an the of})%0a97c97%0a%3c def titlecase(stopwords=%25w{and or a an the of})%0a---%0a> def titlecase(stopwords=%25w{and or and/or a an the of})%0a99c99%0a%3c   t.titlecase!(stopwords)%0a---%0a>   t.titlecase!%0a
host:1354782934=71.63.215.130
author:1354782748=tamara
csum:1354782748=fix it so it works the RIGHT way
diff:1354782748:1354782178:=70c70%0a%3c       stopwords.include?(w.downcase) ? w.downcase : w.capitalize%0a---%0a>       stopwords.include?(w) ? w : w.capitalize%0a78,79c78,79%0a%3c And we'll get it down to 3 lines:%0a%3c %0a---%0a> And we'll get it down to one line:%0a> %0a82,84c82%0a%3c   self.gsub(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a%3c   self[0]=self[0].upcase%0a%3c   self%0a---%0a>   self.capitalize.gsub(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a92,95c90%0a%3c   self.gsub!(/\w+/){|w| stopwords.include?(w.downcase) ? w.downcase%0a%3c     : w.capitalize}%0a%3c   self[0]=self[0].upcase!%0a%3c   self%0a---%0a>   self.capitalize!.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a
host:1354782748=71.63.215.130
author:1354782178=tamara
csum:1354782178=refactor 2
diff:1354782178:1354780504:=78,117d77%0a%3c And we'll get it down to one line:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c def titlecase(stopwords=%25w{and or a an the of})%0a%3c   self.capitalize.gsub(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c Perhaps a way to implement in parallel with the upcase and upcase! methods:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="destructive and non-destructive versions":)%0a%3c def titlecase!(stopwords=%25w{and or and/or a an the of})%0a%3c   self.capitalize!.gsub!(/\w+/){|w| stopwords.include?(w) ? w.downcase : w.capitalize}%0a%3c end%0a%3c def titlecase(stopwords=%25w{and or and/or a an the of})%0a%3c   t = self.dup%0a%3c   t.titlecase!%0a%3c end%0a%3c %0a%3c # assign a string%0a%3c p = "the and, without further adieu, some international incident or other caused us to pray"%0a%3c # => "the and, without further adieu, some international incident or other caused us to pray" %0a%3c %0a%3c # Non-destructive form:%0a%3c p.titlecase%0a%3c # => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a%3c %0a%3c # unchanged from original%0a%3c p%0a%3c # => "the and, without further adieu, some international incident or other caused us to pray" %0a%3c %0a%3c %0a%3c # destructive form:%0a%3c p.titlecase!%0a%3c # => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a%3c %0a%3c # changed original%0a%3c p%0a%3c # => "The and, Without Further Adieu, Some International Incident or Other Caused Us To Pray" %0a%3c (:sourceend:)%0a
host:1354782178=71.63.215.130
author:1354780504=tamara
csum:1354780504=refactor
diff:1354780504:1354778969:=52a53,54%0a> %0a> %0a62,74d63%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c And another way to implement the method:%0a%3c %0a%3c (:source lang=ruby linenum:)%0a%3c   def titlecase(stopwords=%25w{and or and/or a an the of})%0a%3c     t = self.gsub(/\w+/) do |w|%0a%3c       stopwords.include?(w) ? w : w.capitalize%0a%3c     end%0a%3c     t[0]=t[0].upcase%0a%3c     t # return the full string%0a%3c   end%0a
host:1354780504=71.63.215.130
author:1354778969=tamara
csum:1354778969=add example showing stop words
diff:1354778969:1354778568:=52,63d51%0a%3c %0a%3c %0a%3c %0a%3c =begin%0a%3c %0a%3c    Passing in our own list of stop words:%0a%3c    Note that the first character of the string is **always** up-cased.%0a%3c %0a%3c =end%0a%3c "the quick and the dead".titlecase(%25w{the dead})%0a%3c # => "The Quick And the dead" %0a%3c %0a
host:1354778969=71.63.215.130
author:1354778568=tamara
csum:1354778568=new page
diff:1354778568:1354778568:=1,63d0%0a%3c [[#excerpt]]%0a%3c On the ruby-talk list, someone was trying to implement method to convert a string to title case, using [[stop words]] that would not get capitalized.%0a%3c [[#excerptend]]%0a%3c %0a%3c !! Adding a method to an existing class%0a%3c %0a%3c In [[Ruby]], it's very simple to add a new method to a class. All you have to do is re-open the class:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="titlecase.rb":)%0a%3c =begin%0a%3c   %0a%3c    In ruby, the String class includes methods for converting to upper%0a%3c    and lower case (upcase and downcase). It doesn't seem to include the%0a%3c    conversion to title case, however, much less the opportunity to%0a%3c    include stop words (words which will not be converted).%0a%3c %0a%3c    This is a quick example to show how to add a method to String that%0a%3c    will do this.%0a%3c %0a%3c =end %0a%3c %0a%3c class String%0a%3c %0a%3c =begin%0a%3c %0a%3c    The titlecase method will return a string where the words in phrase%0a%3c    are converted to capitalized words, unless a word is in the list of%0a%3c    stopwords. The first word will be capitalized regardless of whether%0a%3c    it's in the stopword list or not.%0a%3c %0a%3c    You can pass in your own list of stopwords as well.%0a%3c %0a%3c =end%0a%3c   def titlecase(stopwords=%25w{and or and/or a an the of})%0a%3c     t = self.split.each do |w|%0a%3c       w[0]=w[0].upcase unless stopwords.include?(w)%0a%3c       w%0a%3c     end.join(" ")%0a%3c     t[0]=t[0].upcase # force first word to upper case, regardless%0a%3c     t # return the full string%0a%3c   end%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c Then:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c require 'titlecase'%0a%3c %0a%3c "the quick brown fox or a rabbit in the hen house of love and his doggie".titlecase%0a%3c # => "The Quick Brown Fox or a Rabbit In the Hen House of Love and His Doggie" %0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary:A example of extending a Ruby class, and implementing a useful method besides.%0a%3c Parent:(Technology.)Ruby%0a%3c IncludeMe:[[(Technology.)Ruby]]%0a%3c Categories:[[!HowTos]]%0a%3c Tags: ruby, classes, string, titlecase%0a%3c (:tags-hide ruby, classes, string, titlecase :)%0a%3c >>%3c%3c%0a\ No newline at end of file%0a
host:1354778568=71.63.215.130
