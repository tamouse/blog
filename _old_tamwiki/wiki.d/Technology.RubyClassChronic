version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.110 Safari/537.36
author=tamara
charset=ISO-8859-1
csum=
ctime=1352398247
host=23.30.226.45
name=Technology.RubyClassChronic
rev=4
targets=Technology.RubyClassChronic,Technology.Ruby,Technology.Remind,Technology.IncludeMe,Category.Articles,Category.HowTos
text=[[#excerpt]]%0a[[Chronic -> http://chronic.rubyforge.org]] is a [[Ruby]] gem that can parse a huge variety of date and time formats. %0a[[#excerptend]]%0a%0a!! Synopsis%0a%0aTaken from [[README -> http://chronic.rubyforge.org/files/README.html]] file:%0a%0a(:source lang=bash header="Installing Chronic":)%0a$ sudo gem install chronic%0a(:sourceend:)%0a%0a(:source lang=ruby linenum tabwidth=4 header="Using Chronic":)%0arequire 'chronic'%0a%0aTime.now%0a # => 2012-11-08 12:06:49 -0600 %0a%0aChronic.parse("tomorrow")%0a  # => 2012-11-09 12:00:00 -0600 %0a%0aChronic.parse("monday", :context => :past)%0a  # => 2012-11-05 12:00:00 -0600 %0a(:sourceend:)%0a%0a''Note: This module might make a ''great'' improvement over the [[remind -> Technology.Remind]] tool's syntax.''%0a%0a!! Some gotchas%0a%0aChronic is good, but sometimes it's a little.. errmmm "chronic".%0a%0a''(Note: these are run with [@Chronic.debug=true@])''	%0a%0a%0a!!! Next Hour On the Hour%0a%0aJust giving "next hour" always seems to give half past the next hour mark:%0a%0a(:source lang=ruby:)%0aChronic.parse "next hour"%0a# +---------------------------------------------------%0a# | [next(grabber-next) , hour(repeater-hour) ]%0a# +---------------------------------------------------%0a# -anchor%0a# Handler: handle_r%0a# Handler-class: Chronic::RepeaterHour%0a# --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a#--(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a# => 2013-06-06 13:30:00 -0500 %0a(:sourceend:)%0a%0aOkay, this doesn't actually work:%0a%0a(:source lang=ruby:)%0aChronic.parse "next hour on the hour"%0a# +---------------------------------------------------%0a# | [next(grabber-next) , hour(repeater-hour) , on(separator-on) , hour(repeater-hour) ]%0a# +---------------------------------------------------%0a# -none%0a# => nil %0a(:sourceend:)%0a%0aNor does this:%0a%0a(:source lang=ruby:)%0aChronic.parse "next hour at 0 minutes"%0a# +---------------------------------------------------%0a# | [next(grabber-next) , hour(repeater-hour) , at(separator-at) , 0(repeater-time-0?, scalar, scalar-year-2000) , minutes(repeater-minute) ]%0a# +---------------------------------------------------%0a# -anchor%0a# Handler: handle_r%0a# Handler-class: Chronic::RepeaterDayPortion%0a# --(2013-06-07 06:00:00 -0500..2013-06-07 18:00:00 -0500)%0a# --(2013-06-07 06:00:00 -0500..2013-06-07 18:00:00 -0500)%0a# --(2013-06-07 06:00:00 -0500..2013-06-07 07:00:00 -0500)%0a# --(2013-06-07 06:00:00 -0500..2013-06-07 06:01:00 -0500)%0a#  => nil %0a(:sourceend:)%0a%0a!!!! Solution?%0a%0aI came up with this fugly thing:%0a%0a(:source lang=ruby:)%0aChronic.parse("next hour", guess: false).first%0a# +---------------------------------------------------%0a# | [next(grabber-next) , hour(repeater-hour) ]%0a# +---------------------------------------------------%0a# -anchor%0a# Handler: handle_r%0a# Handler-class: Chronic::RepeaterHour%0a# --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a# --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a#  => 2013-06-06 13:00:00 -0500 %0a(:sourceend:)%0a%0a%0a%0a%0a>>comment%3c%3c%0aSummary:Chronic is a Ruby class that allows you to find timestamps based on natural (human) language"%0aParent:(Technology.)Ruby%0aIncludeMe:[[(Technology.)Ruby]]%0aCategories:[[!Articles]],[[!HowTos]]%0aTags: ruby, date parsing, gems%0a(:tags-hide ruby, date parsing, gems :)%0a>>%3c%3c
time=1370541766
author:1370541766=tamara
diff:1370541766:1370541666:=2c2%0a%3c [[Chronic -> http://chronic.rubyforge.org]] is a [[Ruby]] gem that can parse a huge variety of date and time formats. %0a---%0a> [[Chronic -> http://chronic.rubyforge.org]] is a [[Ruby]] gem that can parse a huge variety of date and time formats. Following is a small sample of strings that will be properly parsed. Parsing is case insensitive and will handle common abbreviations and misspellings.%0a
host:1370541766=23.30.226.45
author:1370541666=tamara
csum:1370541666=Chronic gotchas
diff:1370541666:1352398496:=27,97d26%0a%3c %0a%3c !! Some gotchas%0a%3c %0a%3c Chronic is good, but sometimes it's a little.. errmmm "chronic".%0a%3c %0a%3c ''(Note: these are run with [@Chronic.debug=true@])''	%0a%3c %0a%3c %0a%3c !!! Next Hour On the Hour%0a%3c %0a%3c Just giving "next hour" always seems to give half past the next hour mark:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c Chronic.parse "next hour"%0a%3c # +---------------------------------------------------%0a%3c # | [next(grabber-next) , hour(repeater-hour) ]%0a%3c # +---------------------------------------------------%0a%3c # -anchor%0a%3c # Handler: handle_r%0a%3c # Handler-class: Chronic::RepeaterHour%0a%3c # --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a%3c #--(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a%3c # => 2013-06-06 13:30:00 -0500 %0a%3c (:sourceend:)%0a%3c %0a%3c Okay, this doesn't actually work:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c Chronic.parse "next hour on the hour"%0a%3c # +---------------------------------------------------%0a%3c # | [next(grabber-next) , hour(repeater-hour) , on(separator-on) , hour(repeater-hour) ]%0a%3c # +---------------------------------------------------%0a%3c # -none%0a%3c # => nil %0a%3c (:sourceend:)%0a%3c %0a%3c Nor does this:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c Chronic.parse "next hour at 0 minutes"%0a%3c # +---------------------------------------------------%0a%3c # | [next(grabber-next) , hour(repeater-hour) , at(separator-at) , 0(repeater-time-0?, scalar, scalar-year-2000) , minutes(repeater-minute) ]%0a%3c # +---------------------------------------------------%0a%3c # -anchor%0a%3c # Handler: handle_r%0a%3c # Handler-class: Chronic::RepeaterDayPortion%0a%3c # --(2013-06-07 06:00:00 -0500..2013-06-07 18:00:00 -0500)%0a%3c # --(2013-06-07 06:00:00 -0500..2013-06-07 18:00:00 -0500)%0a%3c # --(2013-06-07 06:00:00 -0500..2013-06-07 07:00:00 -0500)%0a%3c # --(2013-06-07 06:00:00 -0500..2013-06-07 06:01:00 -0500)%0a%3c #  => nil %0a%3c (:sourceend:)%0a%3c %0a%3c !!!! Solution?%0a%3c %0a%3c I came up with this fugly thing:%0a%3c %0a%3c (:source lang=ruby:)%0a%3c Chronic.parse("next hour", guess: false).first%0a%3c # +---------------------------------------------------%0a%3c # | [next(grabber-next) , hour(repeater-hour) ]%0a%3c # +---------------------------------------------------%0a%3c # -anchor%0a%3c # Handler: handle_r%0a%3c # Handler-class: Chronic::RepeaterHour%0a%3c # --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a%3c # --(2013-06-06 13:00:00 -0500..2013-06-06 14:00:00 -0500)%0a%3c #  => 2013-06-06 13:00:00 -0500 %0a%3c (:sourceend:)%0a%3c %0a%3c %0a
host:1370541666=23.30.226.45
author:1352398496=tamara
csum:1352398496=collapse link to chronic rdoc with first use of chronic
diff:1352398496:1352398247:minor=2c2,4%0a%3c [[Chronic -> http://chronic.rubyforge.org]] is a [[Ruby]] gem that can parse a huge variety of date and time formats. Following is a small sample of strings that will be properly parsed. Parsing is case insensitive and will handle common abbreviations and misspellings.%0a---%0a> [[Chronic rdoc -> http://chronic.rubyforge.org]]%0a> %0a> Chronic can parse a huge variety of date and time formats. Following is a small sample of strings that will be properly parsed. Parsing is case insensitive and will handle common abbreviations and misspellings.%0a
host:1352398496=75.144.38.217
author:1352398247=tamara
csum:1352398247=new page
diff:1352398247:1352398247:=1,38d0%0a%3c [[#excerpt]]%0a%3c [[Chronic rdoc -> http://chronic.rubyforge.org]]%0a%3c %0a%3c Chronic can parse a huge variety of date and time formats. Following is a small sample of strings that will be properly parsed. Parsing is case insensitive and will handle common abbreviations and misspellings.%0a%3c [[#excerptend]]%0a%3c %0a%3c !! Synopsis%0a%3c %0a%3c Taken from [[README -> http://chronic.rubyforge.org/files/README.html]] file:%0a%3c %0a%3c (:source lang=bash header="Installing Chronic":)%0a%3c $ sudo gem install chronic%0a%3c (:sourceend:)%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="Using Chronic":)%0a%3c require 'chronic'%0a%3c %0a%3c Time.now%0a%3c  # => 2012-11-08 12:06:49 -0600 %0a%3c %0a%3c Chronic.parse("tomorrow")%0a%3c   # => 2012-11-09 12:00:00 -0600 %0a%3c %0a%3c Chronic.parse("monday", :context => :past)%0a%3c   # => 2012-11-05 12:00:00 -0600 %0a%3c (:sourceend:)%0a%3c %0a%3c ''Note: This module might make a ''great'' improvement over the [[remind -> Technology.Remind]] tool's syntax.''%0a%3c %0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary:Chronic is a Ruby class that allows you to find timestamps based on natural (human) language"%0a%3c Parent:(Technology.)Ruby%0a%3c IncludeMe:[[(Technology.)Ruby]]%0a%3c Categories:[[!Articles]],[[!HowTos]]%0a%3c Tags: ruby, date parsing, gems%0a%3c (:tags-hide ruby, date parsing, gems :)%0a%3c >>%3c%3c%0a\ No newline at end of file%0a
host:1352398247=75.144.38.217
