version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4
author=tamara
charset=ISO-8859-1
csum=add category
ctime=1288634735
host=75.144.38.217
name=Technology.HowToSetUpForDebuggingInPHP
rev=17
targets=Technology.HowToSetUpForDebuggingInPHP,Technology.PHP,Technology.IncludeMe,Category.HowTos,Category.BestPractices
text=[[#excerpt]]%0aDebugging PHP can be a major pain. If you're not using something like [[Xdebug -> http://xdebug.org]], typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a[[#excerptend]]%0a%0a%0aAlso, see the [[section on php.net about debugging -> http://us2.php.net/manual/en/debugger.php]].%0a%0a!!Syntax Check (aka Lint)%0a%0aPHP will not ever show syntax errors on output when run from a web server, instead they are sent to the web server error log (or php error log if set separately). This can be a struggle if you're running in an edit-test-debug cycle.%0a%0aInstead of trying to syntax check PHP code via the web server with a browser call, run PHP with the @@-l@@ (lint) option:%0a%0a(:source lang=bash:)%0a$ php -l source.php%0a(:sourceend:)%0a%0aThis will easily report any syntax errors in your PHP script. Some `IDEs of course, have this built in, but you can probably wire it to whatever editor or IDE you use.%0a%0aFor example, in emacs, you can use the @@M-x compile@@ command, and change the default command to @@php -l file.php@@ where @@file.php@@ is the currently file you're editing.%0a%0a!!Make sure you see everything PHP reports%0a%0aBy default in most set-ups, error reporting is set for a production server, and errors are logged to the php error log as determined in @@/etc/php.ini@@. This is not very useful when developing and testing your application.%0a%0aTo see what notices, warnings and errors PHP is reporting, add the following to the beginning of your scripts, or put in an include file that is used by every pprogram (such as a initialization or configuration script).%0a%0a(:source lang=php linenum:)%0aerror_reporting(-1); // turns on absolutely ALL error reporting%0aini_set('display_errors',true); // will show errors on PHP output%0aini_set('display_startup_errors',true); // will show startup errors on PHP output%0a(:sourceend:)%0a%0a!!Setting up a debug mechanism%0a%0aThere are many ways to set up a debugging mechanism. Rather than simply inserting echo statements everywhere, it can be helpful to have a function to handle debug output, which can check a global or environment variable to determine the debugging state or level.%0a%0aIn addition, it is quite useful to know where your debug statements are being executed from. In many cases, this may be obvious, but PHP provides some special constants that can help pinpoint where the action is:%0a%0a* [@__FILE__@] - the name of the current file being processed%0a* [@__LINE__@] - the current line of the current file%0a* [@__FUNCTION__@] - the name of the currently executing function%0a* [@__CLASS__@] - the name of the current class%0a* [@__METhOD__@] - the name of the current method in the current class%0a%0aIn my scripts, I typically have a function (or class) that handles the actual debugging display task, and can be called with something like:%0a%0a(:source lang=php:)%0adebug("Message",$var,__FILE__,__LINE__);%0a(:sourceend:)%0a%0awhich will emit the message, dump the variable, and tag the output with the current file and line number.%0a%0aThe function takes care of checking whether the debugging is turned on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a%0a!!Using the query string or post vars to turn debugging on or off%0a%0aMy scheme uses the query string or post vars on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a%0aTo set this up, I include the following in my @@config.inc.php@@ file, which gets called at the beginning of every script in the application:%0a%0a(:source lang=php linenum  tabwidth=4:)%0aif ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true'))%0a{%0a	$GLOBALS['debug']=TRUE;%0a	error_reporting(-1); //report every error%0a	ini_set('display_errors',TRUE); // send error messages to output%0a	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a} else {%0a	$GLOBALS['debug']=FALSE;	%0a}%0a(:sourceend:)%0a%0aAs you can see, this set the global @@debug@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment.%0a%0a!!Short example%0aWhen you are creating an application, and wish to see what is being passed into the script, you can easily include the following at the beginning of the script (after you've set up the environment as above):%0a%0a(:source lang=php linenum:)%0adebug("\$_GET: ",$_GET);%0adebug("\$_POST: ",$_POST);%0a(:sourceend:)%0a%0a!!Creating the debug function%0a%0aThe debug function can be in a self-contained script which you include (and the environment setup can be included in this script as well if you'd like).%0a%0a(:source lang=php linenum tabwidth=4 header="A rudimentary debug function":)%0afunction debug($msg,$var,$file='',$line='')%0a{%0a	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%0a	echo "%3cpre>";%0a	echo "DEBUG: $file @ $line $msg".PHP_EOL;%0a	if (! is_scalar($var)) {%0a		echo htmlspecialchars(print_r($var),true);%0a	} else {%0a		echo htmlspecialchars($var);%0a	}%0a	echo PHP_EOL."%3c/pre>".PHP_EOL;%0a}%0a(:sourceend:)%0a%0a%0a!!More advanced debug features%0a%0a!!!Flexible formatting%0a%0aSomething you may want to do is be able to determine how the messages are formatted, instead of simply using the @@%3cpre>..%3c/pre>@@ HTML tags as shown in the function above, in which case, you can again set globals, sessions or, in this case, define constants to be used to wrap the debug message.%0a%0aAn easy way to do this is set defined constants as the prefix and suffix of the debug output. In the are where you set up the debug environment, you can add something like:%0a%0a(:source lang=php linenum header="Setting debug prefix and suffix":)%0adefine('DEBUGPREFIX','%3cp class="debug">'.PHP_EOL);%0adefine('DEBUGSUFFIX','%3c/p>'.PHP_EOL);%0a(:sourceend:)%0a%0aThen modify the function above as follows:%0a%0a(:source lang=php linenum tabwidth=4 header="A rudimentary debug function":)%0afunction debug($msg,$var,$file='',$line='')%0a{%0a	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%0a	echo (defined('DEBUGPREFIX')?DEBUGPREFIX:PHP_EOL."%3cpre>".PHP_EOL);%0a	echo "DEBUG: $file @ $line $msg".PHP_EOL;%0a	if (! is_scalar($var)) {%0a		echo htmlspecialchars(print_r($var),true);%0a	} else {%0a		echo htmlspecialchars($var);%0a	}%0a	echo (defined('DEBUGSUFFIX')?DEBUGSUFFIX:PHP_EOL."%3c/pre>".PHP_EOL);%0a}%0a(:sourceend:)%0a%0a%0a!!!Defering debug output until later%0a%0aSometimes, you don't want the debugging information written right at the point it is called. Instead, you can create a global or session variable that will hold the debugging messages until the point you want to emit them. %0a%0a(:source lang=php linenum tabwidth=4 header="Defining a global to hold debug messages":)%0a$GLOBALS['debug_output'] = array(); // initialize this global near the beginning of your script%0a(:sourceend:)%0a%0a(:source lang=php linenum tabwidth=4 header="Modified debug script":)%0afunction debug($msg,$var,$file='',$line='')%0a{%0a	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%0a	$out = "DEBUG: $file @ $line $msg".PHP_EOL;%0a	if (! is_scalar($var)) {%0a		$out .= htmlspecialchars(print_r($var),true);%0a	} else {%0a		$out .= htmlspecialchars($var);%0a	}%0a	$GLOBALS['debug_output'][] = $out;%0a}%0a(:sourceend:)%0a%0aLater, to print out all the debug messages (perhaps in a flash section of your application's output):%0a%0a(:source lang=php linenum tabwidth=4 header="Emitting the saved debug messages":)%0aif (isset($GLOBALS['debug_output'] && count($GLOBALS['debug_output']) > 0) {%0a	echo '%3cul class="debug">'.PHP_EOL;%0a	foreach ($GLOBALS['debug_output'] as $l) {%0a		echo "%3cli>$l%3c/li>".PHP_EOL;%0a	}%0a	echo '%3c/ul>'.PHP_EOL;%0a}%0a(:sourceend:)%0a%0a!!! Persistent debug state over multiple requests%0a%0aSometimes, you want to be able to have the debug flag set over multiple requests, form posts, and or redirects. This can be done in a few ways:%0a%0a# %25item value=1%25Use a cookie. Check the existence of the debug cookie for the application, and if set, turn debugging on. If the cookie is not set, then check for the debug parameter in the $_REQUEST superglobal. Additionally, if the debug cookie exists and is turned on, check the $_REQUEST superglobal to see if debugging should be turned off.%0a%0a(:source lang=php linenum tabwidth=4 header="Using a cookie to maintain debug state":)%0aif ((isset($_COOKIE['debug']) && strtolower($_COOKIE['debug']) == 'true')%0a{%0a	$GLOBALS['debug']=true;%0a}%0a%0aif ((isset($_REQUEST['debug']))%0a{%0a	if (strtolower($_REQUEST['debug']) == 'true')%0a	{%0a		$GLOBALS['debug']=TRUE;%0a		error_reporting(-1); //report every error%0a		ini_set('display_errors',TRUE); // send error messages to output%0a		ini_set('display_startup_errors',TRUE); // send startup messages to output%0a		setcookie('cookie','true');%0a	} else {%0a		$GLOBALS['debug']=FALSE;%0a		setcookie('cookie','',time() - 3600); // expiration that is past effectively deletes cookie%0a	}%0a}%0a(:sourceend:)%0a%0a# %25item value=2%25Use a session variable to set the debug state, which will be carried over to every other script called within the same session.%0a%0a(:source lang=php linenum tabwidth=4 header="Using a cookie to maintain debug state":)%0asession_start();%0a%0aif ((isset($_SESSION['debug']) && strtolower($_SESSION['debug']) == TRUE)%0a{%0a	$GLOBALS['debug']=TRUE; // you could also modify the debug function above to use the session variable directly%0a}%0a%0aif ((isset($_REQUEST['debug']))%0a{%0a	if (strtolower($_REQUEST['debug']) == 'true')%0a	{%0a		$GLOBALS['debug']=TRUE;%0a		error_reporting(-1); //report every error%0a		ini_set('display_errors',TRUE); // send error messages to output%0a		ini_set('display_startup_errors',TRUE); // send startup messages to output%0a		$_SESSION['debug']=TRUE;%0a	} else {%0a		$GLOBALS['debug']=FALSE;%0a		$_SESSION['debug']=FALSE;%0a	}%0a}%0a(:sourceend:)%0a%0a# %25item value=3%25Ensure each link and form submision has a debug parameter on it. This is the most intrusive and time-consuming way of dealing with this issue. If you go this route, you may want to write a function that automatically appends the debug flag on all application links and in forms before sending them to the browser.%0a%0a%0a%0a!!A debug class%0a%0aTo put the above ideas together, and add a few more, I've written a debug class script [[class.debug.php in git repo here -> https://gitorious.org/common-php-code/common-php-code]] that can be included in the application to handle debugging in a more interesting fashion.%0a%0aTo use the class, include the file and instantiate the class as an object:%0a%0a(:source lang=php linenum tabwidth=4 header="initializing the class":)%0ainclude_once('class.debug.php');%0a$GLOBALS['dbg'] = new Debug(FALSE);%0a(:sourceend:)%0a%0aBy default, this will turn debugging off, use HTML in debug output, use the standard error logging facility, emit output directly, and use a standard prefix and suffix for the debugging output.%0a%0aFollow this with your environment set up as described at the beggining of this page, only use methods to turn debugging on or off depending of the environment:%0a%0a(:source lang=php linenum  tabwidth=4 hilight=5:)%0aif ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true') ||%0a    (isset($_SERVER['DEBUG']) && strtolower($_SERVER['DEBUG']) == 'true'))%0a{%0a	$GLOBALS['dbg']->on();%0a	error_reporting(-1); //report every error%0a	ini_set('display_errors',TRUE); // send error messages to output%0a	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a}%0a(:sourceend:)%0a%0aThen, to make debug statements, insert the line:%0a%0a(:source lang=php linenum tabwitch=4:)%0a$GLOBALS['dbg']->p("Debug message",$var,__FILE__,__LINE__);%0a(:sourceend:)%0a%0awhere you want your debug output to appear.%0a%0aThe class contains a number of initialization parameters and  methods, which are documented in the source file.%0a%0a!!The problem with doing redirects while debugging%0a%0aOftentimes, one script will do some processing and then redirect to another script to finish up and display the actual results. When debugging, you don't always want this to happen so you can see what's going on on the page you're working on without losing the potential debugging output when a page redirects.%0a%0aThus, I've come up with the following function to handle those situations:%0a%0a(:source lang=php linenum tabwidth=4 header="function to deal with redirectcs while debugging":)%0afunction do_redirect($u)%0a{%0a	debug("Redirect:",$u,__FILE__,__LINE__);%0a	if (!$GLOBALS['debug']) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a}%0a(:sourceend:)%0a%0aIn the above function, the redirect url is passed to the debug print function, then, if debugging is of, will send the redirect header; otherwise it will print an HTML link to enable the redirect to be manually executed after the debug information has been seen by the developer.%0a%0a>>comment%3c%3c%0aSummary:a good way to set up for debugging in PHP%0aParent:(Technology.)PHP%0aIncludeMe:[[(Technology.)PHP]]%0aCategories:[[!HowTos]], [[!BestPractices]]%0aTags: php, debugging%0a(:tags-hide php, debugging :)%0a>>%3c%3c%0a
time=1352136690
author:1352136690=tamara
csum:1352136690=add category
diff:1352136690:1339475648:minor=286c286%0a%3c Categories:[[!HowTos]], [[!BestPractices]]%0a---%0a> Categories:[[!HowTos]]%0a
host:1352136690=75.144.38.217
author:1339475648=tamara
csum:1339475648=syntax error
diff:1339475648:1339475194:=125c125%0a%3c 	echo (defined('DEBUGPREFIX')?DEBUGPREFIX:PHP_EOL."%3cpre>".PHP_EOL);%0a---%0a> 	echo (defined('DEBUGPREFIX')?DEBUGPREFIX:PHP_EOL."%3cpre>".PHP_EOL;%0a132c132%0a%3c 	echo (defined('DEBUGSUFFIX')?DEBUGSUFFIX:PHP_EOL."%3c/pre>".PHP_EOL);%0a---%0a> 	echo (defined('DEBUGSUFFIX')?DEBUGSUFFIX:PHP_EOL."%3c/pre>".PHP_EOL;%0a
host:1339475648=71.63.211.0
author:1339475194=tamara
csum:1339475194=rewrite, streamline
diff:1339475194:1339472753:=18,19c18,19%0a%3c This will easily report any syntax errors in your PHP script. Some `IDEs of course, have this built in, but you can probably wire it to whatever editor or IDE you use.%0a%3c %0a---%0a> This will easily report any syntax errors in your PHP script. Some IDEs of course, have this built in, but you can probably wire it to whatever editor or IDE you use.%0a> %0a56,57c56,57%0a%3c !!Using the query string or post vars to turn debugging on or off%0a%3c %0a---%0a> !!Using the query string or post vars%0a> %0a63,64c63,69%0a%3c if ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true'))%0a%3c {%0a---%0a> /**%0a>  * Allow debug option to be set on the query string or post value, or a server environment variable (useful for command line stuff)%0a>  **/%0a> if ((isset($_REQUEST['debug']) && %0a> 	strtolower($_REQUEST['debug']) == 'true') ||%0a>     (isset($_SERVER['DEBUG']) && %0a> 	strtolower($_SERVER['DEBUG']) == 'true')) {%0a75a81,86%0a> >>checkblack%3c%3c%0a> One way this can be persisted over multiple pages is to use a cookie. Check the existence of the debug cookie for the application, and if set, turn debugging on. If the cookie is not set, then check for the debug parameter in the $_REQUEST superglobal. Additionally, if the debug cookie exists and is turned on, check the $_REQUEST superglobal to see if debugging should be turned off.%0a> %0a> Another way to do this is to use a session variable to set the debug state, which will be carried over to every other script called within the same session.%0a> >>%3c%3c%0a> %0a171,228d181%0a%3c %0a%3c !!! Persistent debug state over multiple requests%0a%3c %0a%3c Sometimes, you want to be able to have the debug flag set over multiple requests, form posts, and or redirects. This can be done in a few ways:%0a%3c %0a%3c # %25item value=1%25Use a cookie. Check the existence of the debug cookie for the application, and if set, turn debugging on. If the cookie is not set, then check for the debug parameter in the $_REQUEST superglobal. Additionally, if the debug cookie exists and is turned on, check the $_REQUEST superglobal to see if debugging should be turned off.%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="Using a cookie to maintain debug state":)%0a%3c if ((isset($_COOKIE['debug']) && strtolower($_COOKIE['debug']) == 'true')%0a%3c {%0a%3c 	$GLOBALS['debug']=true;%0a%3c }%0a%3c %0a%3c if ((isset($_REQUEST['debug']))%0a%3c {%0a%3c 	if (strtolower($_REQUEST['debug']) == 'true')%0a%3c 	{%0a%3c 		$GLOBALS['debug']=TRUE;%0a%3c 		error_reporting(-1); //report every error%0a%3c 		ini_set('display_errors',TRUE); // send error messages to output%0a%3c 		ini_set('display_startup_errors',TRUE); // send startup messages to output%0a%3c 		setcookie('cookie','true');%0a%3c 	} else {%0a%3c 		$GLOBALS['debug']=FALSE;%0a%3c 		setcookie('cookie','',time() - 3600); // expiration that is past effectively deletes cookie%0a%3c 	}%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c # %25item value=2%25Use a session variable to set the debug state, which will be carried over to every other script called within the same session.%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="Using a cookie to maintain debug state":)%0a%3c session_start();%0a%3c %0a%3c if ((isset($_SESSION['debug']) && strtolower($_SESSION['debug']) == TRUE)%0a%3c {%0a%3c 	$GLOBALS['debug']=TRUE; // you could also modify the debug function above to use the session variable directly%0a%3c }%0a%3c %0a%3c if ((isset($_REQUEST['debug']))%0a%3c {%0a%3c 	if (strtolower($_REQUEST['debug']) == 'true')%0a%3c 	{%0a%3c 		$GLOBALS['debug']=TRUE;%0a%3c 		error_reporting(-1); //report every error%0a%3c 		ini_set('display_errors',TRUE); // send error messages to output%0a%3c 		ini_set('display_startup_errors',TRUE); // send startup messages to output%0a%3c 		$_SESSION['debug']=TRUE;%0a%3c 	} else {%0a%3c 		$GLOBALS['debug']=FALSE;%0a%3c 		$_SESSION['debug']=FALSE;%0a%3c 	}%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c # %25item value=3%25Ensure each link and form submision has a debug parameter on it. This is the most intrusive and time-consuming way of dealing with this issue. If you go this route, you may want to write a function that automatically appends the debug flag on all application links and in forms before sending them to the browser.%0a%3c %0a%3c %0a
host:1339475194=71.63.211.0
author:1339472753=tamara
diff:1339472753:1339467181:=8,15c8,40%0a%3c !!Syntax Check (aka Lint)%0a%3c %0a%3c PHP will not ever show syntax errors on output when run from a web server, instead they are sent to the web server error log (or php error log if set separately). This can be a struggle if you're running in an edit-test-debug cycle.%0a%3c %0a%3c Instead of trying to syntax check PHP code via the web server with a browser call, run PHP with the @@-l@@ (lint) option:%0a%3c %0a%3c (:source lang=bash:)%0a%3c $ php -l source.php%0a---%0a> !!Using the query string or post vars%0a> %0a> My scheme uses the query string or post vars on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a> %0a> To set this up, I include the following in my @@config.inc.php@@ file, which gets called at the beginning of every script in the application:%0a> %0a> (:source lang=php linenum  tabwidth=4:)%0a> /**%0a>  * set up some strings to identify debug information in output%0a>  */%0a> define('DEBUGPREFIX','%3cp class="debug">');%0a> define('DEBUGSUFFIX','%3c/p>');%0a> %0a> /**%0a>  * Setting some operating values from the query string%0a>  */%0a> $additional_query_parms = Array();%0a> %0a> /**%0a>  * Allow debug option to be set on the query string or post value, or a server environment variable (useful for command line stuff)%0a>  **/%0a> if ((isset($_REQUEST['debug']) && %0a> 	strtolower($_REQUEST['debug']) == 'true') ||%0a>     (isset($_SERVER['DEBUG']) && %0a> 	strtolower($_SERVER['DEBUG']) == 'true')) {%0a> 	$GLOBALS['debug']=TRUE;%0a> 	error_reporting(-1); //report every error%0a> 	ini_set('display_errors',TRUE); // send error messages to output%0a> 	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a> 	$additional_query_parms['debug'] = 'true'; // ensure debugging is carried through with subsequent redirects and url calls%0a> } else {%0a> 	$GLOBALS['debug']=FALSE;	%0a> }%0a18,31c43,70%0a%3c This will easily report any syntax errors in your PHP script. Some IDEs of course, have this built in, but you can probably wire it to whatever editor or IDE you use.%0a%3c %0a%3c For example, in emacs, you can use the @@M-x compile@@ command, and change the default command to @@php -l file.php@@ where @@file.php@@ is the currently file you're editing.%0a%3c %0a%3c !!Make sure you see everything PHP reports%0a%3c %0a%3c By default in most set-ups, error reporting is set for a production server, and errors are logged to the php error log as determined in @@/etc/php.ini@@. This is not very useful when developing and testing your application.%0a%3c %0a%3c To see what notices, warnings and errors PHP is reporting, add the following to the beginning of your scripts, or put in an include file that is used by every pprogram (such as a initialization or configuration script).%0a%3c %0a%3c (:source lang=php linenum:)%0a%3c error_reporting(-1); // turns on absolutely ALL error reporting%0a%3c ini_set('display_errors',true); // will show errors on PHP output%0a%3c ini_set('display_startup_errors',true); // will show startup errors on PHP output%0a---%0a> As you can see, this set the global @@debug@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a> %0a> >>checkblack%3c%3c%0a> Another way to do this is to use a session variable to set the debug state, which will be carried over to every other script called within the same session. See SettingUpSessionInPHP for more details on how to use session variables.%0a> >>%3c%3c%0a> %0a> Then, I set up a couple of functions (in a file I usually call @@[[WriteFunctionsInASeparateInclude|functions.inc.php]]@@ which gets included by @@[[KeepASampleConfig|config.inc.php]]@@ in every script):%0a> %0a> (:source lang=php linenum tabwidth=4:)%0a> /**%0a>  * debug function - print a message if DEBUG === TRUE%0a>  **/%0a> function debug($msg,$var='',$file='',$line='')%0a> {%0a> 	if (!$GLOBALS['debug']) return;%0a> 	$out = '';%0a> 	if (defined('DEBUGPREFIX') $out .= DEBUGPREFIX;%0a> 	$out .= "DEBUG";%0a> 	if (!empty($file) $out .= ' in '.$file;%0a> 	if (!empty($line) $out .= '@'.$line.": ";%0a> 	$out .= $msg.PHP_EOL;%0a> 	if (!empty($var) {%0a> 		$out .= "%3cpre>" . (!is_scalar($var) ? htmlentities(print_r($var,true)) : htmlentities($var)) . "%3c/pre>" . PHP_EOL;%0a> 	}%0a> 	if (defined('DEBUGSUFFIX') $out .= DEBUGSUFFIX;%0a> 	error_log($out); // send message to syslog%0a> 	echo $out;%0a> }%0a34,49c73,79%0a%3c !!Setting up a debug mechanism%0a%3c %0a%3c There are many ways to set up a debugging mechanism. Rather than simply inserting echo statements everywhere, it can be helpful to have a function to handle debug output, which can check a global or environment variable to determine the debugging state or level.%0a%3c %0a%3c In addition, it is quite useful to know where your debug statements are being executed from. In many cases, this may be obvious, but PHP provides some special constants that can help pinpoint where the action is:%0a%3c %0a%3c * [@__FILE__@] - the name of the current file being processed%0a%3c * [@__LINE__@] - the current line of the current file%0a%3c * [@__FUNCTION__@] - the name of the currently executing function%0a%3c * [@__CLASS__@] - the name of the current class%0a%3c * [@__METhOD__@] - the name of the current method in the current class%0a%3c %0a%3c In my scripts, I typically have a function (or class) that handles the actual debugging display task, and can be called with something like:%0a%3c %0a%3c (:source lang=php:)%0a%3c debug("Message",$var,__FILE__,__LINE__);%0a---%0a> Notice that the string is output wrapped by @@DEBUGPREFIX@@ and @@DEBUGSUFFIX@@ defined above to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc.php@@ file before the include of @@function.inc.php@@.)%0a> %0a> @@debug()@@ let's you print out a string of info with an optional variable, as well as the current file and line number. If the variable is an array, it gets formatted by the @@[[http://us.php.net/manual/en/function.print-r.php|print_r()]]@@.%0a> To call @@debug@@, place a line similar to:%0a> %0a> (:source lang=php linenum tabwidth=4:)%0a> debug("The current value of var is:",$var,__FILE__,__LINE__);%0a52,62c82,100%0a%3c which will emit the message, dump the variable, and tag the output with the current file and line number.%0a%3c %0a%3c The function takes care of checking whether the debugging is turned on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a%3c %0a%3c !!Using the query string or post vars%0a%3c %0a%3c My scheme uses the query string or post vars on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a%3c %0a%3c To set this up, I include the following in my @@config.inc.php@@ file, which gets called at the beginning of every script in the application:%0a%3c %0a%3c (:source lang=php linenum  tabwidth=4:)%0a---%0a> The function takes care of checking whether the @@DEBUG@@ flag is set on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a> %0a> Thus, in many cases, I have something like the following at the front of every script:%0a> %0a> (:source lang=php linenum:)%0a> debug("\$_GET: ",$_GET);%0a> debug("\$_POST: ",$_POST);%0a> (:sourceend:)%0a> %0a> Just to see what is getting passed into each script. If a configuration file gets included early, I'll usually just throw those two lines in there.%0a> %0a> %0a> !!The problem with [[HandlingRedirectsInPHP|redirects]] when debugging%0a> %0a> Oftentimes, one script will do some processing and then redirect to another script to finish up and display the actual results. When debugging, you don't always want this to happen so you can see what's going on on the page you're working on without losing the potential debugging out when a page redirects.%0a> %0a> Thus, I've come up with the following function to handle those situations:%0a> %0a> (:source lang=php linenum:)%0a64c102,105%0a%3c  * Allow debug option to be set on the query string or post value, or a server environment variable (useful for command line stuff)%0a---%0a>  * perform a redirect to the indicated url $u, applying other parameters as needed.%0a>  *%0a>  * @return none - will either redirect or exit%0a>  * @author Tamara Temple%0a66,75c107,112%0a%3c if ((isset($_REQUEST['debug']) && %0a%3c 	strtolower($_REQUEST['debug']) == 'true') ||%0a%3c     (isset($_SERVER['DEBUG']) && %0a%3c 	strtolower($_SERVER['DEBUG']) == 'true')) {%0a%3c 	$GLOBALS['debug']=TRUE;%0a%3c 	error_reporting(-1); //report every error%0a%3c 	ini_set('display_errors',TRUE); // send error messages to output%0a%3c 	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a%3c } else {%0a%3c 	$GLOBALS['debug']=FALSE;	%0a---%0a> function do_redirect($u)%0a> {%0a> 	if (!isset($u)) $u = DEFAULT_REDIRECT;%0a> 	$u = buildredirect($u);%0a> 	debug("Redirect: \$u=$u");%0a> 	if (!$GLOBALS['debug']) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a79,92c116,131%0a%3c As you can see, this set the global @@debug@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment.%0a%3c %0a%3c >>checkblack%3c%3c%0a%3c One way this can be persisted over multiple pages is to use a cookie. Check the existence of the debug cookie for the application, and if set, turn debugging on. If the cookie is not set, then check for the debug parameter in the $_REQUEST superglobal. Additionally, if the debug cookie exists and is turned on, check the $_REQUEST superglobal to see if debugging should be turned off.%0a%3c %0a%3c Another way to do this is to use a session variable to set the debug state, which will be carried over to every other script called within the same session.%0a%3c >>%3c%3c%0a%3c %0a%3c !!Short example%0a%3c When you are creating an application, and wish to see what is being passed into the script, you can easily include the following at the beginning of the script (after you've set up the environment as above):%0a%3c %0a%3c (:source lang=php linenum:)%0a%3c debug("\$_GET: ",$_GET);%0a%3c debug("\$_POST: ",$_POST);%0a---%0a> The effect of the above function is to create a redirect string then when debugging, print out the redirect string and a link to the redirect and exit. When not debugging, the redirect happens the normal way.%0a> %0a> The @@buildredirect()@@ function is a nice utility for creating useful redirects with additional query attributes. See [[HandlingRedirectsInPHP]].%0a> %0a> %0a> !!! Advanced Debugging Features%0a> %0a> The above is great for doing rudimentary debugging in a straight-forward fashion. Sometimes, though, you want to do things a bit more precisely to keep things neat within an application.%0a> %0a> As such, I've written a debug class script [[(Attach:class.debug.phps]] that can be included in the application to handle debugging in a more interesting fashion.%0a> %0a> Place this into a common include file, such as @@config.inc.php@@:%0a> %0a> (:source lang=php linenum tabwidth=4:)%0a> include_once('class.debug.php');%0a> $dbg = new Debug();%0a95,112c134,139%0a%3c !!Creating the debug function%0a%3c %0a%3c The debug function can be in a self-contained script which you include (and the environment setup can be included in this script as well if you'd like).%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="A rudimentary debug function":)%0a%3c function debug($msg,$var,$file='',$line='')%0a%3c {%0a%3c 	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%3c %0a%3c 	echo "%3cpre>";%0a%3c 	echo "DEBUG: $file @ $line $msg".PHP_EOL;%0a%3c 	if (! is_scalar($var)) {%0a%3c 		echo htmlspecialchars(print_r($var),true);%0a%3c 	} else {%0a%3c 		echo htmlspecialchars($var);%0a%3c 	}%0a%3c 	echo PHP_EOL."%3c/pre>".PHP_EOL;%0a%3c }%0a---%0a> By default, this will turn debugging on, use HTML in debug output, use the standard error logging facility, emit output directly, and use a standard prefix and suffix for the debugging output.%0a> %0a> Then, to make debug statements, insert the line:%0a> %0a> (:source lang=php linenum tabwitch=4:)%0a> $dbg->p("Debug message",$var,__FILE__,__LINE__);%0a115,214d141%0a%3c %0a%3c !!More advanced debug features%0a%3c %0a%3c !!!Flexible formatting%0a%3c %0a%3c Something you may want to do is be able to determine how the messages are formatted, instead of simply using the @@%3cpre>..%3c/pre>@@ HTML tags as shown in the function above, in which case, you can again set globals, sessions or, in this case, define constants to be used to wrap the debug message.%0a%3c %0a%3c An easy way to do this is set defined constants as the prefix and suffix of the debug output. In the are where you set up the debug environment, you can add something like:%0a%3c %0a%3c (:source lang=php linenum header="Setting debug prefix and suffix":)%0a%3c define('DEBUGPREFIX','%3cp class="debug">'.PHP_EOL);%0a%3c define('DEBUGSUFFIX','%3c/p>'.PHP_EOL);%0a%3c (:sourceend:)%0a%3c %0a%3c Then modify the function above as follows:%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="A rudimentary debug function":)%0a%3c function debug($msg,$var,$file='',$line='')%0a%3c {%0a%3c 	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%3c %0a%3c 	echo (defined('DEBUGPREFIX')?DEBUGPREFIX:PHP_EOL."%3cpre>".PHP_EOL;%0a%3c 	echo "DEBUG: $file @ $line $msg".PHP_EOL;%0a%3c 	if (! is_scalar($var)) {%0a%3c 		echo htmlspecialchars(print_r($var),true);%0a%3c 	} else {%0a%3c 		echo htmlspecialchars($var);%0a%3c 	}%0a%3c 	echo (defined('DEBUGSUFFIX')?DEBUGSUFFIX:PHP_EOL."%3c/pre>".PHP_EOL;%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c !!!Defering debug output until later%0a%3c %0a%3c Sometimes, you don't want the debugging information written right at the point it is called. Instead, you can create a global or session variable that will hold the debugging messages until the point you want to emit them. %0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="Defining a global to hold debug messages":)%0a%3c $GLOBALS['debug_output'] = array(); // initialize this global near the beginning of your script%0a%3c (:sourceend:)%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="Modified debug script":)%0a%3c function debug($msg,$var,$file='',$line='')%0a%3c {%0a%3c 	if (!isset($GLOBALS['debug']) || !$GLOBALS['debug']) return; // fast return if not debugging%0a%3c %0a%3c 	$out = "DEBUG: $file @ $line $msg".PHP_EOL;%0a%3c 	if (! is_scalar($var)) {%0a%3c 		$out .= htmlspecialchars(print_r($var),true);%0a%3c 	} else {%0a%3c 		$out .= htmlspecialchars($var);%0a%3c 	}%0a%3c 	$GLOBALS['debug_output'][] = $out;%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c Later, to print out all the debug messages (perhaps in a flash section of your application's output):%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="Emitting the saved debug messages":)%0a%3c if (isset($GLOBALS['debug_output'] && count($GLOBALS['debug_output']) > 0) {%0a%3c 	echo '%3cul class="debug">'.PHP_EOL;%0a%3c 	foreach ($GLOBALS['debug_output'] as $l) {%0a%3c 		echo "%3cli>$l%3c/li>".PHP_EOL;%0a%3c 	}%0a%3c 	echo '%3c/ul>'.PHP_EOL;%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c !!A debug class%0a%3c %0a%3c To put the above ideas together, and add a few more, I've written a debug class script [[class.debug.php in git repo here -> https://gitorious.org/common-php-code/common-php-code]] that can be included in the application to handle debugging in a more interesting fashion.%0a%3c %0a%3c To use the class, include the file and instantiate the class as an object:%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="initializing the class":)%0a%3c include_once('class.debug.php');%0a%3c $GLOBALS['dbg'] = new Debug(FALSE);%0a%3c (:sourceend:)%0a%3c %0a%3c By default, this will turn debugging off, use HTML in debug output, use the standard error logging facility, emit output directly, and use a standard prefix and suffix for the debugging output.%0a%3c %0a%3c Follow this with your environment set up as described at the beggining of this page, only use methods to turn debugging on or off depending of the environment:%0a%3c %0a%3c (:source lang=php linenum  tabwidth=4 hilight=5:)%0a%3c if ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true') ||%0a%3c     (isset($_SERVER['DEBUG']) && strtolower($_SERVER['DEBUG']) == 'true'))%0a%3c {%0a%3c 	$GLOBALS['dbg']->on();%0a%3c 	error_reporting(-1); //report every error%0a%3c 	ini_set('display_errors',TRUE); // send error messages to output%0a%3c 	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c Then, to make debug statements, insert the line:%0a%3c %0a%3c (:source lang=php linenum tabwitch=4:)%0a%3c $GLOBALS['dbg']->p("Debug message",$var,__FILE__,__LINE__);%0a%3c (:sourceend:)%0a%3c %0a217,240c144,150%0a%3c The class contains a number of initialization parameters and  methods, which are documented in the source file.%0a%3c %0a%3c !!The problem with doing redirects while debugging%0a%3c %0a%3c Oftentimes, one script will do some processing and then redirect to another script to finish up and display the actual results. When debugging, you don't always want this to happen so you can see what's going on on the page you're working on without losing the potential debugging output when a page redirects.%0a%3c %0a%3c Thus, I've come up with the following function to handle those situations:%0a%3c %0a%3c (:source lang=php linenum tabwidth=4 header="function to deal with redirectcs while debugging":)%0a%3c function do_redirect($u)%0a%3c {%0a%3c 	debug("Redirect:",$u,__FILE__,__LINE__);%0a%3c 	if (!$GLOBALS['debug']) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c In the above function, the redirect url is passed to the debug print function, then, if debugging is of, will send the redirect header; otherwise it will print an HTML link to enable the redirect to be manually executed after the debug information has been seen by the developer.%0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary:a good way to set up for debugging in PHP%0a%3c Parent:(Technology.)PHP%0a%3c IncludeMe:[[(Technology.)PHP]]%0a%3c Categories:[[!HowTos]]%0a%3c Tags: php, debugging%0a---%0a> The class contains a number of methods, which are documented in the source file.%0a> %0a> (:Summary:a good way to set up for debugging in PHP:)%0a> (:Parent:(Technology.)PHP:)%0a> (:IncludeMe:[[(Technology.)PHP]]:)%0a> (:Categories:[[!HowTos]]:)%0a> (:Tags: php, debugging:)%0a242d151%0a%3c >>%3c%3c%0a
host:1339472753=71.63.211.0
author:1339467181=tamara
diff:1339467181:1334714369:=
host:1339467181=71.63.211.0
author:1334714369=ImportText
diff:1334714369:1317242389:=1c1,8%0a%3c [[#excerpt]]%0a---%0a> (:Summary:a good way to set up for debugging in PHP:)%0a> %0a> %25trail%25 ComputerStuff \\%0a> SoftwareAndWebProgramming\\%0a> %3c%3c|[[PHP]]|>>%0a> %0a> Also, see the [[section on php.net about debugging -> http://us2.php.net/manual/en/debugger.php]].%0a> %0a3,9c10,12%0a%3c [[#excerptend]]%0a%3c %0a%3c %0a%3c Also, see the [[section on php.net about debugging -> http://us2.php.net/manual/en/debugger.php]].%0a%3c %0a%3c !!Using the query string or post vars%0a%3c %0a---%0a> %0a> !!!Using the query string or post vars%0a> %0a94,95c97,98%0a%3c !!The problem with [[HandlingRedirectsInPHP|redirects]] when debugging%0a%3c %0a---%0a> !!!The problem with [[HandlingRedirectsInPHP|redirects]] when debugging%0a> %0a146,151c149,151%0a%3c (:Summary:a good way to set up for debugging in PHP:)%0a%3c (:Parent:(Technology.)PHP:)%0a%3c (:IncludeMe:[[(Technology.)PHP]]:)%0a%3c (:Categories:[[!HowTos]]:)%0a%3c (:Tags: php, debugging:)%0a%3c (:tags-hide php, debugging :)%0a---%0a> %25categories%25 '''Categories:''' [[!ComputerStuff]]%0a> %0a> %25tags%25 '''Tags:''' (:tags php, debugging, best practices, web development, howto:)%0a\ No newline at end of file%0a
host:1334714369=127.0.0.1
author:1317242389=tamara
csum:1317242389=change extension on attached php file
diff:1317242389:1317242130:minor=128c128%0a%3c As such, I've written a debug class script [[(Attach:class.debug.phps]] that can be included in the application to handle debugging in a more interesting fashion.%0a---%0a> As such, I've written a debug class script [[(Attach:class.debug.php.txt]] that can be included in the application to handle debugging in a more interesting fashion.%0a
host:1317242389=71.63.211.0
author:1317242130=tamara
csum:1317242130=update best practice info, add debug class implementation
diff:1317242130:1317238609:=9,10c9,10%0a%3c Debugging PHP can be a major pain. If you're not using something like [[Xdebug -> http://xdebug.org]], typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a%3c %0a---%0a> Debugging PHP can be a major pain. If you're not using something like [[`Xdebug -> http://xdebug.org]], typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a> %0a17c17%0a%3c (:source lang=php linenum  tabwidth=4:)%0a---%0a> (:source lang=php linenum:)%0a19c19%0a%3c  * set up some strings to identify debug information in output%0a---%0a>  * Setting some operating values from the query string%0a21,23c21,22%0a%3c define('DEBUGPREFIX','%3cp class="debug">');%0a%3c define('DEBUGSUFFIX','%3c/p>');%0a%3c %0a---%0a> $additional_query_parms = Array();%0a> %0a25,30c24%0a%3c  * Setting some operating values from the query string%0a%3c  */%0a%3c $additional_query_parms = Array();%0a%3c %0a%3c /**%0a%3c  * Allow debug option to be set on the query string or post value, or a server environment variable (useful for command line stuff)%0a---%0a>  * Allow debug option to be set on the query string or post value%0a32,35c26,27%0a%3c if ((isset($_REQUEST['debug']) && %0a%3c 	strtolower($_REQUEST['debug']) == 'true') ||%0a%3c     (isset($_SERVER['DEBUG']) && %0a%3c 	strtolower($_SERVER['DEBUG']) == 'true')) {%0a---%0a> if ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true') ||%0a>      (isset($_SERVER['DEBUG']) && strtolower($_SERVER['DEBUG']) == 'true')) {%0a37,40c29,32%0a%3c 	error_reporting(-1); //report every error%0a%3c 	ini_set('display_errors',TRUE); // send error messages to output%0a%3c 	ini_set('display_startup_errors',TRUE); // send startup messages to output%0a%3c 	$additional_query_parms['debug'] = 'true'; // ensure debugging is carried through with subsequent redirects and url calls%0a---%0a> 	error_reporting(-1);%0a> 	ini_set('display_errors',TRUE);%0a> 	ini_set('display_startup_errors',TRUE);%0a> 	$additional_query_parms['debug'] = 'true';%0a48,51d39%0a%3c >>checkblack%3c%3c%0a%3c Another way to do this is to use a session variable to set the debug state, which will be carried over to every other script called within the same session. See SettingUpSessionInPHP for more details on how to use session variables.%0a%3c >>%3c%3c%0a%3c %0a54c42%0a%3c (:source lang=php linenum tabwidth=4:)%0a---%0a> (:source lang=php linenum:)%0a56a45,47%0a>  *%0a>  * @return void%0a>  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a60c51%0a%3c 	if (!$GLOBALS['debug']) return;%0a---%0a> 	if (!DEBUG) return;%0a62c53%0a%3c 	if (defined('DEBUGPREFIX') $out .= DEBUGPREFIX;%0a---%0a> 	if (defined(DEBUGPREFIX) $out .= DEBUGPREFIX;%0a68c59%0a%3c 		$out .= "%3cpre>" . (!is_scalar($var) ? htmlentities(print_r($var,true)) : htmlentities($var)) . "%3c/pre>" . PHP_EOL;%0a---%0a> 		$out .= "%3cpre>".(is_array($var)?print_r($var,true):$var)."%3c/pre>".PHP_EOL;%0a70c61%0a%3c 	if (defined('DEBUGSUFFIX') $out .= DEBUGSUFFIX;%0a---%0a> 	if (defined(DEBUGSUFFIX) $out .= DEBUGSUFFIX;%0a76,77c67,68%0a%3c Notice that the string is output wrapped by @@DEBUGPREFIX@@ and @@DEBUGSUFFIX@@ defined above to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc.php@@ file before the include of @@function.inc.php@@.)%0a%3c %0a---%0a> Notice that the string is output wrapped in some extra stuff to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc.php@@ file before the include of @@function.inc.php@@.)%0a> %0a81,84c72,73%0a%3c (:source lang=php linenum tabwidth=4:)%0a%3c debug("The current value of var is:",$var,__FILE__,__LINE__);%0a%3c (:sourceend:)%0a%3c %0a---%0a>     debug("The current value of var is:",$var,__FILE__,__LINE__);%0a> %0a115c104%0a%3c 	if (!$GLOBALS['debug']) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a---%0a> 	if (!DEBUG) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a123,151c112,113%0a%3c %0a%3c !!! Advanced Debugging Features%0a%3c %0a%3c The above is great for doing rudimentary debugging in a straight-forward fashion. Sometimes, though, you want to do things a bit more precisely to keep things neat within an application.%0a%3c %0a%3c As such, I've written a debug class script [[(Attach:class.debug.php.txt]] that can be included in the application to handle debugging in a more interesting fashion.%0a%3c %0a%3c Place this into a common include file, such as @@config.inc.php@@:%0a%3c %0a%3c (:source lang=php linenum tabwidth=4:)%0a%3c include_once('class.debug.php');%0a%3c $dbg = new Debug();%0a%3c (:sourceend:)%0a%3c %0a%3c By default, this will turn debugging on, use HTML in debug output, use the standard error logging facility, emit output directly, and use a standard prefix and suffix for the debugging output.%0a%3c %0a%3c Then, to make debug statements, insert the line:%0a%3c %0a%3c (:source lang=php linenum tabwitch=4:)%0a%3c $dbg->p("Debug message",$var,__FILE__,__LINE__);%0a%3c (:sourceend:)%0a%3c %0a%3c where you want your debug output to appear.%0a%3c %0a%3c The class contains a number of methods, which are documented in the source file.%0a%3c %0a%3c %25categories%25 '''Categories:''' [[!ComputerStuff]]%0a%3c %0a%3c %25tags%25 '''Tags:''' (:tags php, debugging, best practices, web development, howto:)%0a\ No newline at end of file%0a---%0a> %25trail%25 '''Categories:''' [[!ComputerStuff]]%0a> '''Tags:''' (:tags php, debugging, best practices, source code, coding examples, web development:)%0a\ No newline at end of file%0a
host:1317242130=71.63.211.0
author:1317238609=tamara
diff:1317238609:1308213742:=2,4c2,3%0a%3c %0a%3c %25trail%25 ComputerStuff \\%0a%3c SoftwareAndWebProgramming\\%0a---%0a> [[%3c%3c]]%0a> %3c%3c|SoftwareAndWebProgramming|>>\\%0a7,14c6,13%0a%3c Also, see the [[section on php.net about debugging -> http://us2.php.net/manual/en/debugger.php]].%0a%3c %0a%3c Debugging PHP can be a major pain. If you're not using something like [[`Xdebug -> http://xdebug.org]], typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a%3c %0a%3c !!!Using the query string or post vars%0a%3c %0a%3c My scheme uses the query string or post vars on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a%3c %0a---%0a> %0a> %0a> Debugging PHP is a major pain. There is no step-wise debugger available, and there are enough differences between command line and web server execution to make matters worse. Typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a> %0a> !!!Using the query string%0a> %0a> My scheme uses the query string on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a> %0a28c27%0a%3c 	$GLOBALS['debug']=TRUE;%0a---%0a> 	define("DEBUG",TRUE);%0a34c33%0a%3c 	$GLOBALS['debug']=FALSE;	%0a---%0a> 	define("DEBUG",FALSE);	%0a38c37%0a%3c As you can see, this set the global @@debug@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a---%0a> As you can see, this set a constant @@DEBUG@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a
host:1317238609=71.63.211.0
author:1308213742=tamara
csum:1308213742=move tags to bottom
diff:1308213742:1308213693:minor=6,7c6,7%0a%3c %0a%3c %0a---%0a> '''Tags:''' (:tags php, debugging, best practices, source code, coding examples, web development:)%0a> %0a112c112%0a%3c '''Tags:''' (:tags php, debugging, best practices, source code, coding examples, web development:)%0a\ No newline at end of file%0a---%0a> '''Tags:''' (:tags php, debugging, best practices:)%0a\ No newline at end of file%0a
host:1308213742=71.63.211.0
author:1308213693=tamara
csum:1308213693=update how I do debugging
diff:1308213693:1289938552:=25,26c25,26%0a%3c if ((isset($_REQUEST['debug']) && strtolower($_REQUEST['debug']) == 'true') ||%0a%3c      (isset($_SERVER['DEBUG']) && strtolower($_SERVER['DEBUG']) == 'true')) {%0a---%0a> if ((isset($_GET['debug']) && $_GET['debug'] == 'true') ||%0a>      (isset($_POST['debug']) && $_POST['debug'] == 'true')) {%0a28d27%0a%3c 	error_reporting(-1);%0a37,38c36,37%0a%3c As you can see, this set a constant @@DEBUG@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data or from the environment. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a%3c %0a---%0a> As you can see, this set a constant @@DEBUG@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a> %0a48c47%0a%3c function debug($msg,$var='',$file='',$line='')%0a---%0a> function debug($msg)%0a50,58c49,50%0a%3c 	if (!DEBUG) return;%0a%3c 	$out = '';%0a%3c 	if (defined(DEBUGPREFIX) $out .= DEBUGPREFIX;%0a%3c 	$out .= "DEBUG";%0a%3c 	if (!empty($file) $out .= ' in '.$file;%0a%3c 	if (!empty($line) $out .= '@'.$line.": ";%0a%3c 	$out .= $msg.PHP_EOL;%0a%3c 	if (!empty($var) {%0a%3c 		$out .= "%3cpre>".(is_array($var)?print_r($var,true):$var)."%3c/pre>".PHP_EOL;%0a---%0a> 	if (DEBUG) {%0a> 		echo DEBUGPREFIX . "DEBUG: $msg" . DEBUGSUFFIX;%0a60,62d51%0a%3c 	if (defined(DEBUGSUFFIX) $out .= DEBUGSUFFIX;%0a%3c 	error_log($out); // send message to syslog%0a%3c 	echo $out;%0a63a53,68%0a> %0a> /**%0a>  * debug var function - dump a variable if DEBUG === TRUE%0a>  *%0a>  * @return void%0a>  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a>  **/%0a> function debug_var($msg,$var)%0a> {%0a> 	if (DEBUG) {%0a> 		echo DEBUGPREFIX . "DEBUG: $msg" . DEBUGSUFFIX;%0a> 		echo "%3cpre class=\"debug\">\n";%0a> 		var_dump($var);%0a> 		echo "%3c/pre>\n";%0a> 	}%0a> }%0a68,74c73,74%0a%3c @@debug()@@ let's you print out a string of info with an optional variable, as well as the current file and line number. If the variable is an array, it gets formatted by the @@[[http://us.php.net/manual/en/function.print-r.php|print_r()]]@@.%0a%3c To call @@debug@@, place a line similar to:%0a%3c %0a%3c     debug("The current value of var is:",$var,__FILE__,__LINE__);%0a%3c %0a%3c The function takes care of checking whether the @@DEBUG@@ flag is set on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a%3c %0a---%0a> @@debug()@@ let's you print out a string of info. @@debug_var()@@ takes two parameters, a labeling string, and then an object to be printed by @@[[http://us.php.net/manual/en/function.print-r.php|print_r()]]@@. The functions take care of checking whether the @@DEBUG@@ flag is set on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a> %0a78,79c78,81%0a%3c debug("\$_GET: ",$_GET);%0a%3c debug("\$_POST: ",$_POST);%0a---%0a> require_once('config.inc.php');%0a> %0a> debug_var("\$_GET:",$_GET);%0a> debug_var("\$_POST:",$_POST);%0a82,84c84,86%0a%3c Just to see what is getting passed into each script. If a configuration file gets included early, I'll usually just throw those two lines in there.%0a%3c %0a%3c %0a---%0a> Just to see what is getting passed into each script.%0a> %0a> %0a93c95%0a%3c  * perform a redirect to the indicated url $u, applying other parameters as needed.%0a---%0a>  * perform a redirect to the indicated url $u, applying other paramters as needed.%0a111,112c113%0a%3c %25trail%25 '''Categories:''' [[!ComputerStuff]]%0a%3c '''Tags:''' (:tags php, debugging, best practices:)%0a\ No newline at end of file%0a---%0a> %25rframe%25 '''Categories:''' [[!ComputerStuff]]%0a
host:1308213693=71.63.211.0
author:1289938552=tamara
csum:1289938552=fix syntax error in setting debug constant
diff:1289938552:1289638356:=26c26%0a%3c      (isset($_POST['debug']) && $_POST['debug'] == 'true')) {%0a---%0a> 	((isset($_POST['debug']) && $_POST['debug'] == 'true')) {%0a
host:1289938552=71.63.211.0
author:1289638356=tamara
csum:1289638356=change extension from .inc to .php
diff:1289638356:1289462300:minor=14,15c14,15%0a%3c To set this up, I include the following in my @@config.inc.php@@ file, which gets called at the beginning of every script in the application:%0a%3c %0a---%0a> To set this up, I include the following in my @@config.inc@@ file, which gets called at the beginning of every script in the application:%0a> %0a38,39c38,39%0a%3c Then, I set up a couple of functions (in a file I usually call @@[[WriteFunctionsInASeparateInclude|functions.inc.php]]@@ which gets included by @@[[KeepASampleConfig|config.inc.php]]@@ in every script):%0a%3c %0a---%0a> Then, I set up a couple of functions (in a file I usually call @@[[WriteFunctionsInASeparateInclude|functions.inc]]@@ which gets included by @@[[KeepASampleConfig|config.inc]]@@ in every script):%0a> %0a71,72c71,72%0a%3c Notice that the string is output wrapped in some extra stuff to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc.php@@ file before the include of @@function.inc.php@@.)%0a%3c %0a---%0a> Notice that the string is output wrapped in some extra stuff to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc@@ file before the include of @@function.inc@@.)%0a> %0a78c78%0a%3c require_once('config.inc.php');%0a---%0a> require_once('config.inc');%0a
host:1289638356=71.63.211.0
author:1289462300=tamara
csum:1289462300=modify debug_var to use var_dump instead of print_r
diff:1289462300:1288649543:=64,65c64,65%0a%3c 		echo "%3cpre class=\"debug\">\n";%0a%3c 		var_dump($var);%0a---%0a> 		echo "%3cpre>\n";%0a> 		print_r($var);%0a
host:1289462300=71.63.211.0
author:1288649543=tamara
diff:1288649543:1288649240:=38,39c38,39%0a%3c Then, I set up a couple of functions (in a file I usually call @@[[WriteFunctionsInASeparateInclude|functions.inc]]@@ which gets included by @@[[KeepASampleConfig|config.inc]]@@ in every script):%0a%3c %0a---%0a> Then, I set up a couple of functions (in a file I usually call @@functions.inc@@ which gets included by @@config.inc@@ in every script):%0a> %0a87,88c87,88%0a%3c !!!The problem with [[HandlingRedirectsInPHP|redirects]] when debugging%0a%3c %0a---%0a> !!!The problem with redirects when debugging%0a> %0a113c113%0a%3c %25rframe%25 '''Categories:''' [[!ComputerStuff]]%0a---%0a> %25rframe%25 '''Categories:''' [[!Uncategorized]]%0a
host:1288649543=71.63.211.0
author:1288649240=tamara
diff:1288649240:1288634735:=16c16%0a%3c (:source lang=php linenum:)%0a---%0a> (:source lang=php linenum -trim:)%0a40c40%0a%3c (:source lang=php linenum:)%0a---%0a> (:source lang=php linenum -trim:)%0a77c77%0a%3c (:source lang=php linenum:)%0a---%0a> (:source lang=php linenum -trim:)%0a93c93%0a%3c (:source lang=php linenum:)%0a---%0a> (:source lang=php linenum -trim:)%0a
host:1288649240=71.63.211.0
author:1288634735=tamara
diff:1288634735:1288634735:=1,113d0%0a%3c (:Summary:a good way to set up for debugging in PHP:)%0a%3c [[%3c%3c]]%0a%3c %3c%3c|SoftwareAndWebProgramming|>>\\%0a%3c %3c%3c|[[PHP]]|>>%0a%3c %0a%3c '''Tags:''' (:tags php, debugging, best practices, source code, coding examples, web development:)%0a%3c %0a%3c Debugging PHP is a major pain. There is no step-wise debugger available, and there are enough differences between command line and web server execution to make matters worse. Typically, debugging PHP is done via printing out variables and state information to the browser as your application is running. Turning debugging on and off is sometimes a major pain. I've devised  scheme to make it much simpler.%0a%3c %0a%3c !!!Using the query string%0a%3c %0a%3c My scheme uses the query string on any PHP script call to include the parameter @@debug=true@@. Thus to call a script and turn on debugging, one could use http://www.example.com/myscript.php?debug=true.%0a%3c %0a%3c To set this up, I include the following in my @@config.inc@@ file, which gets called at the beginning of every script in the application:%0a%3c %0a%3c (:source lang=php linenum -trim:)%0a%3c /**%0a%3c  * Setting some operating values from the query string%0a%3c  */%0a%3c $additional_query_parms = Array();%0a%3c %0a%3c /**%0a%3c  * Allow debug option to be set on the query string or post value%0a%3c  **/%0a%3c if ((isset($_GET['debug']) && $_GET['debug'] == 'true') ||%0a%3c 	((isset($_POST['debug']) && $_POST['debug'] == 'true')) {%0a%3c 	define("DEBUG",TRUE);%0a%3c 	ini_set('display_errors',TRUE);%0a%3c 	ini_set('display_startup_errors',TRUE);%0a%3c 	$additional_query_parms['debug'] = 'true';%0a%3c } else {%0a%3c 	define("DEBUG",FALSE);	%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c As you can see, this set a constant @@DEBUG@@ to true or false depending on the existence and value of the @@debug@@ parameter on either the query string or from the post data. The @@$additional_query_parms@@ is an array to keep track of any additional query or post info that might be needed to add to redirect urls or urls in the emitted html code, thus allowing the debug flag to be set once and perpetuated to other script calls.%0a%3c %0a%3c Then, I set up a couple of functions (in a file I usually call @@functions.inc@@ which gets included by @@config.inc@@ in every script):%0a%3c %0a%3c (:source lang=php linenum -trim:)%0a%3c /**%0a%3c  * debug function - print a message if DEBUG === TRUE%0a%3c  *%0a%3c  * @return void%0a%3c  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a%3c  **/%0a%3c function debug($msg)%0a%3c {%0a%3c 	if (DEBUG) {%0a%3c 		echo DEBUGPREFIX . "DEBUG: $msg" . DEBUGSUFFIX;%0a%3c 	}%0a%3c }%0a%3c %0a%3c /**%0a%3c  * debug var function - dump a variable if DEBUG === TRUE%0a%3c  *%0a%3c  * @return void%0a%3c  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a%3c  **/%0a%3c function debug_var($msg,$var)%0a%3c {%0a%3c 	if (DEBUG) {%0a%3c 		echo DEBUGPREFIX . "DEBUG: $msg" . DEBUGSUFFIX;%0a%3c 		echo "%3cpre>\n";%0a%3c 		print_r($var);%0a%3c 		echo "%3c/pre>\n";%0a%3c 	}%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c Notice that the string is output wrapped in some extra stuff to make it apparent this is debugging code. (The constants are typically defined in the @@config.inc@@ file before the include of @@function.inc@@.)%0a%3c %0a%3c @@debug()@@ let's you print out a string of info. @@debug_var()@@ takes two parameters, a labeling string, and then an object to be printed by @@[[http://us.php.net/manual/en/function.print-r.php|print_r()]]@@. The functions take care of checking whether the @@DEBUG@@ flag is set on, so you can simply embed the debugging calls into your script and forget about them. I tend to leave the debugging calls in until I've thoroughly tested the code. Code under development seems to work better with debugging things left in.%0a%3c %0a%3c Thus, in many cases, I have something like the following at the front of every script:%0a%3c %0a%3c (:source lang=php linenum -trim:)%0a%3c require_once('config.inc');%0a%3c %0a%3c debug_var("\$_GET:",$_GET);%0a%3c debug_var("\$_POST:",$_POST);%0a%3c (:sourceend:)%0a%3c %0a%3c Just to see what is getting passed into each script.%0a%3c %0a%3c %0a%3c !!!The problem with redirects when debugging%0a%3c %0a%3c Oftentimes, one script will do some processing and then redirect to another script to finish up and display the actual results. When debugging, you don't always want this to happen so you can see what's going on on the page you're working on without losing the potential debugging out when a page redirects.%0a%3c %0a%3c Thus, I've come up with the following function to handle those situations:%0a%3c %0a%3c (:source lang=php linenum -trim:)%0a%3c /**%0a%3c  * perform a redirect to the indicated url $u, applying other paramters as needed.%0a%3c  *%0a%3c  * @return none - will either redirect or exit%0a%3c  * @author Tamara Temple%0a%3c  **/%0a%3c function do_redirect($u)%0a%3c {%0a%3c 	if (!isset($u)) $u = DEFAULT_REDIRECT;%0a%3c 	$u = buildredirect($u);%0a%3c 	debug("Redirect: \$u=$u");%0a%3c 	if (!DEBUG) header("Location: $u"); else exit("%3cp>%3ca href='$u'>Redirect to $u%3c/a>%3c/p>");%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c The effect of the above function is to create a redirect string then when debugging, print out the redirect string and a link to the redirect and exit. When not debugging, the redirect happens the normal way.%0a%3c %0a%3c The @@buildredirect()@@ function is a nice utility for creating useful redirects with additional query attributes. See [[HandlingRedirectsInPHP]].%0a%3c %0a%3c %25rframe%25 '''Categories:''' [[!Uncategorized]]%0a
host:1288634735=71.63.211.0
