version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:17.0) Gecko/20100101 Firefox/17.0
author=tamara
charset=ISO-8859-1
csum=add line number and headers in some source examples
ctime=1357660915
host=71.63.215.130
name=Technology.TheCuriousCaseOfTheFlipflop20130108095131
rev=5
targets=Technology.TheCuriousCaseOfTheFlipflop20130108095131,Technology.Ruby,Category.Articles,Category.Links,Category.Programming,Category.Technology,Category.Ruby,Category.HowTos,Technology.Perl
text=[[#excerpt]]%0aToday I learned what a ruby flip-flop is. I had never seen nor heard of this before now. Below is the article someone pointed me at to explain how it works. I'm still wonering why it works, but I guess this is good enough for now.%0a[[#excerptend]]%0a%0aThe article mentions flip-flops in awk, sed and perl, and I don't know what the author is referring to there, either.%0a%0a([[#examples | some more examples from ruby and perl below]].)%0a%0a>>quote%3c%3c%0a(:nolinkwikiwords:)%0a! The Curious Case of the Flip-Flop%0a%0aBy [[http://ruby.about.com:80/bio/Michael-Morin-44924.htm | Michael Morin]], About.com Guide%0a%0aWhen the [[http://ruby.about.com:80/od/rubysbasicfeatures/ss/Ranges.htm | Range]] operator is used in a [[http://ruby.about.com:80/od/beginningruby/a/loopconditional.htm | conditional statement]], it does something totally unexpected: it doesn't create a Range object. Instead, it acts as a "flip-flop" operator, a feature carried over from archaic text processing languages such as awk, sed and [[http://perl.about.com/ | Perl]]. Though it is a Range analog, of sorts.%0a%0aBut first, a warning. The flip-flop operator is a hotly contested feature of Ruby. It's still struggling to find an [[http://ruby.about.com:80/od/gl/g/Idiom.htm | idiomatic]] use case, except for a few very rarely needed things. It's not something you'll likely reach for on a daily, weekly or even monthly basis. The only thing you really need to know about it is what it does, and that's only in case you encounter it in someone else's code. Many even go as far to say not to use the flip-flop operator, that it only adds confusion. The choice is yours though.%0a%0aThese types of flip-flop expressions look at bit different. First, they're usually in the conditional portion of an [[http://ruby.about.com:80/od/beginningruby/a/loopconditional.htm | if]] or [[http://ruby.about.com:80/od/rubyfeatures/a/loops.htm | while]] statement. Second, the left and right of the Range expression itself are usually boolean expressions. For, for example, it might look something like this.%0a%0a(:source lang=ruby:)%0aif a==3 .. a==5%0a  # Do something %0aend%0a(:sourceend:)%0a%0a%0aThe flip-flop expression will [[http://ruby.about.com:80/od/control/a/Boolean-Expressions.htm | evaluate]] to false until the first (left hand) expression is true. The flip-flop expression will then evaluate to true until the right-hand expression evaluates to true. It will then continue to evaluate to false until the left-hand expression evaluates to true again, and then it will flip the other way. It flips and flops between the true and false state, hence the name "flip-flop."%0a%0aThe flip-flop expression can also be exclusive. With the typical double dot version, when the second expression evaluates to false, the flip-flop expression will evaluate to true that one last time. When using the three dot notation, the flip-flop expression will evaluate to false as soon as the second expression evaluates to false.%0a%0aSo how is this a "range analog" as was mentioned before? In the example above, assuming @@a@@ is a range of 1 to 10, the flip-flop will be true from the values of @@a@@ from 3 to 5 (including 5). In addition, if there are any additional 3's in the sequence, it will also be true for any future sequence of 3 to 5.%0a%0a!! Usage%0a%0aDescribing how to use the flip-flop operator can be tough. Firstly, it's not used very often. In fact, many say not to use it at all. It's archaic, not expressive and can easily lead to confusion. Though it's there in your toolbox, and should you find a need to use it, there's no strong reason not to use it.%0a%0aIt's most often seen used with [[http://ruby.about.com:80/od/regularexpressions/Regular_Expressions.htm | regular expressions]]. Say you want to print all lines from a text file starting with the line that begins with @@BEGIN@@ and ends with the line that begins with @@END@@. You could simply iterate over all the lines of the file, use a single flip-flop in an @@if@@ statement and @@puts@@ the lines.%0a%0aFirst, the data file.%0a%0a(:source lang=text:)%0aThese lines won't be printed.%0aThey're here for debugging purposes only%0aand as notes for other programmers.%0aBEGIN%0aWelcome to Awesome%0aProgram 3.1415%0aPress X to begin!%0aEND%0aAnd these lines won't be%0aprinted either.%0a(:sourceend:)%0a%0a%0aAnd the code. Note that the .. and &hellip; operators bind very loosely, so there's no need for parentheses.%0a%0a(:source lang=ruby linenum:)%0a#!/usr/bin/env ruby%0aFile.readlines(ARGV[0]).each do|l|%0a  if l =~ /^BEGIN/ .. l =~ /^END/%0a    puts l%0a  end%0aend%0a(:sourceend:)%0a%0aYou could also use it to extract ranges of objects from sequences. For example, you have the range of numbers from 1 to 100 and you way to select only the numbers between a multiple of 5 and the next highest multiple of 8. So from 5 to 8, then from 10 to 16, then 20 to 24, etc. Your first try might be something like this (but it would be wrong).%0a%0a(:source lang=ruby:)%0a(1..100).select{|i| i%255==0 .. i%258==0 }%0a(:sourceend:)%0a%0a%0aThis looks reasonable, so why is it wrong? Remember that the flip-flop operator can only be used inside of conditional statements. Here, the @@select@@ [[http://ruby.about.com:80/od/beginningruby/a/blocks.htm | block]] is merely acting on the truthiness of the result of the block passed to it, there is no conditional statement here. The conditional statement must exist to trigger the creation of the flip-flop, it's a special behind the scenes thing that has to happen just right. So you'll have to add a bit of superfluous code to satisfy this need.%0a%0a(:source lang=ruby:)%0a(1..100).select{|i| true if i%255==0 .. i%258==0 }%0a(:sourceend:)%0a%0aThat looks a bit silly, "true if this other thing is true," but it works. Also, the flip-flop can be used wherever a conditional expression is expected, not only in @@if@@ statements. This includes loops and the @@conditional operator@@.%0a%0a&copy;2013 About.com. All rights reserved.%0a(:linkwikiwords:)%0a>>%3c%3c%0a%0a>>comment%3c%3c%0aSummary: The flip-flop operator is a strange case indeed: part range, part conditional.%0aTags: ruby, range, flip flop%0a(:tags-hide ruby, range, flip flop:)%0a(:title The Curious Case of the Flip-Flop:)%0aSource: http://ruby.about.com/od/convolutedconstructions/ss/The-Curious-Case-Of-The-Flip-Flop.htm%0aParent:(Technology.)Ruby%0aincludeme:[[Technology.Ruby]]%0aCategories:[[!Articles]], [[!Links]], [[!Programming]], [[!Technology]], [[!Ruby]], [[!HowTos]]%0a>>%3c%3c%0a%0aPage saved at: Tue, 08 Jan 2013 09:51:31 -0600%0a%0a[[#examples]]%0a!! Some more examples from [[Ruby]] and [[Perl]]%0a%0aIn [[http://perldoc.perl.org/perlop.html#Range-Operators | Perlop Range Operators]], the flip-flop action is the first use of the @@..@@ operator. This makes me very curious since I have never even heard of this usage and I've been using perl for ''decades''.%0a%0aIt seems particularly useful in both Perl and Ruby as away of extracting lines from a file between two delimited text elements:%0a%0a!!! Perl version%0a(:source lang=perl linenum header="The source:":)%0a@lines = (" - Foo",%0a	  "01 - Bar",%0a	  "1 - Baz",%0a	  " - Quux");%0a%0aprint "The source:\n";%0aprint join("\n",@lines)."\n";%0a%0aprint "\nExclusive, double-dot:\n";%0aforeach (@lines) {%0a    if (/0/ .. /1/) {%0a	print "$_\n";%0a    }%0a}%0a%0aprint "\nInclusive, triple-dot:\n";%0aforeach (@lines) {%0a    if (/0/ ... /1/) {%0a	print "$_\n";%0a    }%0a}%0a(:sourceend:)%0a%0a(:source lang=text header="The output:":)%0aThe source:%0a - Foo%0a01 - Bar%0a1 - Baz%0a - Quux%0a%0aExclusive, double-dot:%0a01 - Bar%0a%0aInclusive, triple-dot:%0a01 - Bar%0a1 - Baz%0a(:sourceend:)%0a%0a%0a%0a%0a!!! Ruby version%0a(:source lang=ruby linenum header="The source:":)%0alines = [" - Foo",%0a         "01 - Bar",%0a         "1 - Baz",%0a         " - Quux"];%0a%0aputs "Source:"%0aputs lines%0a%0aputs%0aputs "Exclusive, double-dot:"%0alines.each do |l|%0a  if (l.match(/0/) .. l.match(/1/))%0a    puts "#{l}\n";%0a  end%0aend%0a%0aputs%0aputs "Inclusive, triple-dot:"%0alines.each do |l|%0a  if (l.match(/0/) ... l.match(/1/))%0a    puts "#{l}\n";%0a  end%0aend%0a(:sourceend:)%0a%0a(:source lang=text header="The output:":)%0aSource:%0a - Foo%0a01 - Bar%0a1 - Baz%0a - Quux%0a%0aExclusive, double-dot:%0a01 - Bar%0a%0aInclusive, triple-dot:%0a01 - Bar%0a1 - Baz%0a(:sourceend:)%0a
time=1357663831
title=The Curious Case of the Flip-Flop
author:1357663831=tamara
csum:1357663831=add line number and headers in some source examples
diff:1357663831:1357662508:minor=58c58%0a%3c (:source lang=ruby linenum:)%0a---%0a> (:source lang=ruby:)%0a107c107%0a%3c (:source lang=perl linenum header="The source:":)%0a---%0a> (:source lang=perl:)%0a
host:1357663831=71.63.215.130
author:1357662508=tamara
csum:1357662508=add some examples
diff:1357662508:1357661009:=7,8c7%0a%3c ([[#examples | some more examples from ruby and perl below]].)%0a%3c %0a---%0a> %0a99,189d97%0a%3c [[#examples]]%0a%3c !! Some more examples from [[Ruby]] and [[Perl]]%0a%3c %0a%3c In [[http://perldoc.perl.org/perlop.html#Range-Operators | Perlop Range Operators]], the flip-flop action is the first use of the @@..@@ operator. This makes me very curious since I have never even heard of this usage and I've been using perl for ''decades''.%0a%3c %0a%3c It seems particularly useful in both Perl and Ruby as away of extracting lines from a file between two delimited text elements:%0a%3c %0a%3c !!! Perl version%0a%3c (:source lang=perl:)%0a%3c @lines = (" - Foo",%0a%3c 	  "01 - Bar",%0a%3c 	  "1 - Baz",%0a%3c 	  " - Quux");%0a%3c %0a%3c print "The source:\n";%0a%3c print join("\n",@lines)."\n";%0a%3c %0a%3c print "\nExclusive, double-dot:\n";%0a%3c foreach (@lines) {%0a%3c     if (/0/ .. /1/) {%0a%3c 	print "$_\n";%0a%3c     }%0a%3c }%0a%3c %0a%3c print "\nInclusive, triple-dot:\n";%0a%3c foreach (@lines) {%0a%3c     if (/0/ ... /1/) {%0a%3c 	print "$_\n";%0a%3c     }%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c (:source lang=text header="The output:":)%0a%3c The source:%0a%3c  - Foo%0a%3c 01 - Bar%0a%3c 1 - Baz%0a%3c  - Quux%0a%3c %0a%3c Exclusive, double-dot:%0a%3c 01 - Bar%0a%3c %0a%3c Inclusive, triple-dot:%0a%3c 01 - Bar%0a%3c 1 - Baz%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c %0a%3c %0a%3c !!! Ruby version%0a%3c (:source lang=ruby linenum header="The source:":)%0a%3c lines = [" - Foo",%0a%3c          "01 - Bar",%0a%3c          "1 - Baz",%0a%3c          " - Quux"];%0a%3c %0a%3c puts "Source:"%0a%3c puts lines%0a%3c %0a%3c puts%0a%3c puts "Exclusive, double-dot:"%0a%3c lines.each do |l|%0a%3c   if (l.match(/0/) .. l.match(/1/))%0a%3c     puts "#{l}\n";%0a%3c   end%0a%3c end%0a%3c %0a%3c puts%0a%3c puts "Inclusive, triple-dot:"%0a%3c lines.each do |l|%0a%3c   if (l.match(/0/) ... l.match(/1/))%0a%3c     puts "#{l}\n";%0a%3c   end%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c (:source lang=text header="The output:":)%0a%3c Source:%0a%3c  - Foo%0a%3c 01 - Bar%0a%3c 1 - Baz%0a%3c  - Quux%0a%3c %0a%3c Exclusive, double-dot:%0a%3c 01 - Bar%0a%3c %0a%3c Inclusive, triple-dot:%0a%3c 01 - Bar%0a%3c 1 - Baz%0a%3c (:sourceend:)%0a
host:1357662508=71.63.215.130
author:1357661009=tamara
csum:1357661009=fix formatting on first code sample
diff:1357661009:1357660930:minor=21,23c21%0a%3c if a==3 .. a==5%0a%3c   # Do something %0a%3c end%0a---%0a> if a==3 .. a==5   # Do something end%0a
host:1357661009=71.63.215.130
author:1357660930=tamara
csum:1357660930=Page moved to Technology.TheCuriousCaseOfTheFlipflop20130108095131 from SavedArticles.TheCuriousCaseOfTheFlipflop20130108095131
diff:1357660930:1357660915:=
host:1357660930=71.63.215.130
author:1357660915=tamara
csum:1357660915=new page
diff:1357660915:1357660915:=1,95d0%0a%3c [[#excerpt]]%0a%3c Today I learned what a ruby flip-flop is. I had never seen nor heard of this before now. Below is the article someone pointed me at to explain how it works. I'm still wonering why it works, but I guess this is good enough for now.%0a%3c [[#excerptend]]%0a%3c %0a%3c The article mentions flip-flops in awk, sed and perl, and I don't know what the author is referring to there, either.%0a%3c %0a%3c %0a%3c >>quote%3c%3c%0a%3c (:nolinkwikiwords:)%0a%3c ! The Curious Case of the Flip-Flop%0a%3c %0a%3c By [[http://ruby.about.com:80/bio/Michael-Morin-44924.htm | Michael Morin]], About.com Guide%0a%3c %0a%3c When the [[http://ruby.about.com:80/od/rubysbasicfeatures/ss/Ranges.htm | Range]] operator is used in a [[http://ruby.about.com:80/od/beginningruby/a/loopconditional.htm | conditional statement]], it does something totally unexpected: it doesn't create a Range object. Instead, it acts as a "flip-flop" operator, a feature carried over from archaic text processing languages such as awk, sed and [[http://perl.about.com/ | Perl]]. Though it is a Range analog, of sorts.%0a%3c %0a%3c But first, a warning. The flip-flop operator is a hotly contested feature of Ruby. It's still struggling to find an [[http://ruby.about.com:80/od/gl/g/Idiom.htm | idiomatic]] use case, except for a few very rarely needed things. It's not something you'll likely reach for on a daily, weekly or even monthly basis. The only thing you really need to know about it is what it does, and that's only in case you encounter it in someone else's code. Many even go as far to say not to use the flip-flop operator, that it only adds confusion. The choice is yours though.%0a%3c %0a%3c These types of flip-flop expressions look at bit different. First, they're usually in the conditional portion of an [[http://ruby.about.com:80/od/beginningruby/a/loopconditional.htm | if]] or [[http://ruby.about.com:80/od/rubyfeatures/a/loops.htm | while]] statement. Second, the left and right of the Range expression itself are usually boolean expressions. For, for example, it might look something like this.%0a%3c %0a%3c (:source lang=ruby:)%0a%3c if a==3 .. a==5   # Do something end%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c The flip-flop expression will [[http://ruby.about.com:80/od/control/a/Boolean-Expressions.htm | evaluate]] to false until the first (left hand) expression is true. The flip-flop expression will then evaluate to true until the right-hand expression evaluates to true. It will then continue to evaluate to false until the left-hand expression evaluates to true again, and then it will flip the other way. It flips and flops between the true and false state, hence the name "flip-flop."%0a%3c %0a%3c The flip-flop expression can also be exclusive. With the typical double dot version, when the second expression evaluates to false, the flip-flop expression will evaluate to true that one last time. When using the three dot notation, the flip-flop expression will evaluate to false as soon as the second expression evaluates to false.%0a%3c %0a%3c So how is this a "range analog" as was mentioned before? In the example above, assuming @@a@@ is a range of 1 to 10, the flip-flop will be true from the values of @@a@@ from 3 to 5 (including 5). In addition, if there are any additional 3's in the sequence, it will also be true for any future sequence of 3 to 5.%0a%3c %0a%3c !! Usage%0a%3c %0a%3c Describing how to use the flip-flop operator can be tough. Firstly, it's not used very often. In fact, many say not to use it at all. It's archaic, not expressive and can easily lead to confusion. Though it's there in your toolbox, and should you find a need to use it, there's no strong reason not to use it.%0a%3c %0a%3c It's most often seen used with [[http://ruby.about.com:80/od/regularexpressions/Regular_Expressions.htm | regular expressions]]. Say you want to print all lines from a text file starting with the line that begins with @@BEGIN@@ and ends with the line that begins with @@END@@. You could simply iterate over all the lines of the file, use a single flip-flop in an @@if@@ statement and @@puts@@ the lines.%0a%3c %0a%3c First, the data file.%0a%3c %0a%3c (:source lang=text:)%0a%3c These lines won't be printed.%0a%3c They're here for debugging purposes only%0a%3c and as notes for other programmers.%0a%3c BEGIN%0a%3c Welcome to Awesome%0a%3c Program 3.1415%0a%3c Press X to begin!%0a%3c END%0a%3c And these lines won't be%0a%3c printed either.%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c And the code. Note that the .. and &hellip; operators bind very loosely, so there's no need for parentheses.%0a%3c %0a%3c (:source lang=ruby:)%0a%3c #!/usr/bin/env ruby%0a%3c File.readlines(ARGV[0]).each do|l|%0a%3c   if l =~ /^BEGIN/ .. l =~ /^END/%0a%3c     puts l%0a%3c   end%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c You could also use it to extract ranges of objects from sequences. For example, you have the range of numbers from 1 to 100 and you way to select only the numbers between a multiple of 5 and the next highest multiple of 8. So from 5 to 8, then from 10 to 16, then 20 to 24, etc. Your first try might be something like this (but it would be wrong).%0a%3c %0a%3c (:source lang=ruby:)%0a%3c (1..100).select{|i| i%255==0 .. i%258==0 }%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c This looks reasonable, so why is it wrong? Remember that the flip-flop operator can only be used inside of conditional statements. Here, the @@select@@ [[http://ruby.about.com:80/od/beginningruby/a/blocks.htm | block]] is merely acting on the truthiness of the result of the block passed to it, there is no conditional statement here. The conditional statement must exist to trigger the creation of the flip-flop, it's a special behind the scenes thing that has to happen just right. So you'll have to add a bit of superfluous code to satisfy this need.%0a%3c %0a%3c (:source lang=ruby:)%0a%3c (1..100).select{|i| true if i%255==0 .. i%258==0 }%0a%3c (:sourceend:)%0a%3c %0a%3c That looks a bit silly, "true if this other thing is true," but it works. Also, the flip-flop can be used wherever a conditional expression is expected, not only in @@if@@ statements. This includes loops and the @@conditional operator@@.%0a%3c %0a%3c &copy;2013 About.com. All rights reserved.%0a%3c (:linkwikiwords:)%0a%3c >>%3c%3c%0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary: The flip-flop operator is a strange case indeed: part range, part conditional.%0a%3c Tags: ruby, range, flip flop%0a%3c (:tags-hide ruby, range, flip flop:)%0a%3c (:title The Curious Case of the Flip-Flop:)%0a%3c Source: http://ruby.about.com/od/convolutedconstructions/ss/The-Curious-Case-Of-The-Flip-Flop.htm%0a%3c Parent:(Technology.)Ruby%0a%3c includeme:[[Technology.Ruby]]%0a%3c Categories:[[!Articles]], [[!Links]], [[!Programming]], [[!Technology]], [[!Ruby]], [[!HowTos]]%0a%3c >>%3c%3c%0a%3c %0a%3c Page saved at: Tue, 08 Jan 2013 09:51:31 -0600%0a%3c %0a
host:1357660915=71.63.215.130
