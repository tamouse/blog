version=pmwiki-2.2.36 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:10.0.2) Gecko/20100101 Firefox/10.0.2
author=tamara
charset=ISO-8859-1
csum=(:source lang=html4strict -getcode:) (:source lang=html4strict -getcode:) 
ctime=1330289532
host=71.63.211.0
name=SavedLinks.AListApartArticlesResponsiveImagesHowTheyAlmostWorkedAndWhatWeNeed
rev=3
targets=SavedLinks.HomePage,SavedLinks.IncludeMe,Category.Links,Category.ComputerStuff
text=(:if false:)%0a(:title A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need:)%0aSummary:great article on some issues and needed direction for responsive images in responsive web design%0aParent:SavedLinks(.HomePage)%0aIncludeMe:[[SavedLinks.HomePage]]%0aTags: web design, flexible web design, responsive web design, A List Apart%0a(:tags-hide web design, flexible web design, responsive web design, A List Apart:)%0aCategories:[[!Links]] [[!ComputerStuff]]%0a(:ifend:)%0a%0aLink: [[A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need -> http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/]]%0a%0a(:linebreaks:)%0aby [[Mat Marquis -> http://www.alistapart.com/authors/m/matmarquis]]%0apublished: January 31, 2012%0a(:nolinebreaks:)%0a%0a>>quote%3c%3c%0a(:nolinkwikiwords:)%0aSo, now what?%0a%0aLong after the Boston Globe site launched, we continued to iterate on our approach. Jason Grigsby has done an incredible job documenting the details of those trials and tribulations in a series of blog posts.%0a%0aThis brings us to the present day, with some of the brightest minds on the web looking for something &mdash; anything &mdash; that will get the job done. Some think that it isn't a solvable problem right now, and are placing their bets on user agent detection as a temporary solution. While this is a perfectly viable answer in the short term, I maintain that it's untenable going forward: with the ever-expanding range of mobile phones and tablets in circulation, we could never hope to maintain a reasonable list of browsers and devices for long.%0a%0aI believe that the ultimate solution shouldn't hinge on scripting or CSS &mdash; and certainly nothing like UA detection, cookies, custom scripting on the front end, or any server-side shenanigans. Our aim is to represent and serve content appropriately, and for that reason I believe that this should be solved in markup.%0a%0aThe img tag isn't going to cut it for this, though. It's effective at conveying the hilarious antics of house cats, but it isn't well suited to complex logic. It does one thing, and it does it well: it takes a single image source, and it puts it on your screen. If we were to modify this behavior at the browser level, we would never be able to guarantee our changes wouldn't introduce issues in older browsers. We also know from experience that img doesn't leave us much (if any) room to polyfill this new behavior.%0a%0aWhat we need is a new markup pattern &mdash; one that allows us to specify multiple source files, but still specify universally-recognized markup as  "fallback content" browsers that don't recognize the new tag. This should sound familiar, as this pattern already exists: the video and audio tags.%0a%0aWe know that a video tag can contain references to multiple sources, and that we can specify fallback content within the tag that's only visible to browsers that don't support video natively &mdash; usually a Flash-based video. What you may not know is that there's already a way to use media queries to determine which video source to use, though browser support is a little spotty.%0a%0a%0a(:source lang=html4strict -getcode:)%0a%3cvideo>%0a        %3csource src="high-res.webm" media="min-width:800px" />%0a        %3csource src="low-res.webm" />%0a        %3cimg src="poster.jpg" />%0a%3c/video>%0a(:sourceend:)%0a%0aFrom there, it doesn't take much imagination to see how we could use a pattern like this.%0a%0a%0a(:source lang=html4strict -getcode:)%0a%3cpicture>%0a        %3csource src="high-res.jpg" media="min-width: 800px" />%0a        %3csource src="mobile.jpg" />%0a        %3c!-- Fallback content: -->%0a        %3cimg src="mobile.jpg" />%0a%3c/picture>%0a(:sourceend:)%0a%0aWe could have a limitless number of options by using source media queries &mdash; higher resolution images for high-res displays over a certain size, for example. If we could reliably detect connection speed, one day we may be able to add [@media="connection-speed: edge"@] or [@media="min-speed: 200kbps"@] to our source elements. If these source elements are implemented per the HTML5 spec, a request will only be sent for the ones that match our media query. What we get is a single, highly-tailored request, with conditional flexibility limited only by a constantly growing roster of media queries.%0a%0aOnce we've established that markup as our foundation, we may be able to polyfill the expected behavior for browsers that don't yet support it. While it's likely that the polyfills would still involve more than one request, starting with a tried-and-true fallback pattern would allow us to apply polyfills at our discretion.%0a(:linkwikiwords:)%0a>>%3c%3c%0a(:nolinebreaks:)%0a%0a%0aSaved date: 2012-2-26 14:36%0a%0a%0a%0a
time=1330290072
title=A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need
author:1330290072=tamara
diff:1330290072:1330289750:=35c35%0a%3c (:source lang=html4strict -getcode:)%0a---%0a> (:source lang=html4strict:)%0a46c46%0a%3c (:source lang=html4strict -getcode:)%0a---%0a> (:source lang=html4strict:)%0a
host:1330290072=71.63.211.0
author:1330289750=tamara
diff:1330289750:1330289532:=2d1%0a%3c (:title A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need:)%0a
host:1330289750=71.63.211.0
author:1330289532=tamara
diff:1330289532:1330289532:=1,65d0%0a%3c (:if false:)%0a%3c Summary:great article on some issues and needed direction for responsive images in responsive web design%0a%3c Parent:SavedLinks(.HomePage)%0a%3c IncludeMe:[[SavedLinks.HomePage]]%0a%3c Tags: web design, flexible web design, responsive web design, A List Apart%0a%3c (:tags-hide web design, flexible web design, responsive web design, A List Apart:)%0a%3c Categories:[[!Links]] [[!ComputerStuff]]%0a%3c (:ifend:)%0a%3c %0a%3c Link: [[A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need -> http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/]]%0a%3c %0a%3c (:linebreaks:)%0a%3c by [[Mat Marquis -> http://www.alistapart.com/authors/m/matmarquis]]%0a%3c published: January 31, 2012%0a%3c (:nolinebreaks:)%0a%3c %0a%3c >>quote%3c%3c%0a%3c (:nolinkwikiwords:)%0a%3c So, now what?%0a%3c %0a%3c Long after the Boston Globe site launched, we continued to iterate on our approach. Jason Grigsby has done an incredible job documenting the details of those trials and tribulations in a series of blog posts.%0a%3c %0a%3c This brings us to the present day, with some of the brightest minds on the web looking for something &mdash; anything &mdash; that will get the job done. Some think that it isn't a solvable problem right now, and are placing their bets on user agent detection as a temporary solution. While this is a perfectly viable answer in the short term, I maintain that it's untenable going forward: with the ever-expanding range of mobile phones and tablets in circulation, we could never hope to maintain a reasonable list of browsers and devices for long.%0a%3c %0a%3c I believe that the ultimate solution shouldn't hinge on scripting or CSS &mdash; and certainly nothing like UA detection, cookies, custom scripting on the front end, or any server-side shenanigans. Our aim is to represent and serve content appropriately, and for that reason I believe that this should be solved in markup.%0a%3c %0a%3c The img tag isn't going to cut it for this, though. It's effective at conveying the hilarious antics of house cats, but it isn't well suited to complex logic. It does one thing, and it does it well: it takes a single image source, and it puts it on your screen. If we were to modify this behavior at the browser level, we would never be able to guarantee our changes wouldn't introduce issues in older browsers. We also know from experience that img doesn't leave us much (if any) room to polyfill this new behavior.%0a%3c %0a%3c What we need is a new markup pattern &mdash; one that allows us to specify multiple source files, but still specify universally-recognized markup as  "fallback content" browsers that don't recognize the new tag. This should sound familiar, as this pattern already exists: the video and audio tags.%0a%3c %0a%3c We know that a video tag can contain references to multiple sources, and that we can specify fallback content within the tag that's only visible to browsers that don't support video natively &mdash; usually a Flash-based video. What you may not know is that there's already a way to use media queries to determine which video source to use, though browser support is a little spotty.%0a%3c %0a%3c %0a%3c (:source lang=html4strict:)%0a%3c %3cvideo>%0a%3c         %3csource src="high-res.webm" media="min-width:800px" />%0a%3c         %3csource src="low-res.webm" />%0a%3c         %3cimg src="poster.jpg" />%0a%3c %3c/video>%0a%3c (:sourceend:)%0a%3c %0a%3c From there, it doesn't take much imagination to see how we could use a pattern like this.%0a%3c %0a%3c %0a%3c (:source lang=html4strict:)%0a%3c %3cpicture>%0a%3c         %3csource src="high-res.jpg" media="min-width: 800px" />%0a%3c         %3csource src="mobile.jpg" />%0a%3c         %3c!-- Fallback content: -->%0a%3c         %3cimg src="mobile.jpg" />%0a%3c %3c/picture>%0a%3c (:sourceend:)%0a%3c %0a%3c We could have a limitless number of options by using source media queries &mdash; higher resolution images for high-res displays over a certain size, for example. If we could reliably detect connection speed, one day we may be able to add [@media="connection-speed: edge"@] or [@media="min-speed: 200kbps"@] to our source elements. If these source elements are implemented per the HTML5 spec, a request will only be sent for the ones that match our media query. What we get is a single, highly-tailored request, with conditional flexibility limited only by a constantly growing roster of media queries.%0a%3c %0a%3c Once we've established that markup as our foundation, we may be able to polyfill the expected behavior for browsers that don't yet support it. While it's likely that the polyfills would still involve more than one request, starting with a tried-and-true fallback pattern would allow us to apply polyfills at our discretion.%0a%3c (:linkwikiwords:)%0a%3c >>%3c%3c%0a%3c (:nolinebreaks:)%0a%3c %0a%3c %0a%3c Saved date: 2012-2-26 14:36%0a%3c %0a%3c %0a%3c %0a
host:1330289532=71.63.211.0
