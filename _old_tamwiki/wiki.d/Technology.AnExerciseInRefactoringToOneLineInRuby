version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:15.0) Gecko/20100101 Firefox/15.0.1
author=tamara
charset=ISO-8859-1
csum=added more versions, OP and others
ctime=1352263490
host=71.63.215.130
name=Technology.AnExerciseInRefactoringToOneLineInRuby
rev=2
targets=Technology.AnExerciseInRefactoringToOneLineInRuby,Technology.Development,Technology.IncludeMe,Category.HowTos
text=[[#excerpt]]%0aIn a recent [[post -> http://www.ruby-forum.com/topic/4407569]] on the [[ruby-talk mailing list -> http://www.ruby-forum.com/forum/ruby]], a poster asked how they could get a field from a few records out of a file on one line.%0a[[#excerptend]]%0a%0aThis was the OP's starting point:%0a%0a(:source lang=ruby header="Original Poster's concept:":)%0aoutput=`cat #{file} | grep  "up    down" | grep "aenet" | awk '{print $6}'`%0aputs output%0a(:sourceend:)%0a%0aReally not quite getting the power of @@awk@@ here, I think.%0a%0aThe data file we were tasked to work with:%0a%0a(:source header="data":)%0axe-0/0/2.0              up    up   aenet    --> ae1.0%0axe-0/0/3                up    up%0axe-0/0/3.0              up    up   aenet    --> ae1.0%0a%0axe-10/0/6.0             up    down aenet    --> ae40.0%0axe-24/0/3.0             up    down aenet    --> ae30.0%0a(:sourceend:)%0a%0a(There was more cruft, but it's really irrelevant.)%0a%0aThere were a few respondents with some longish rubyisms:%0a%0a(:source lang=ruby linenum tabwidth=4 +getcode header="Another Respondent's Attempt:":)%0arequire 'stringio'%0a%0af = StringIO.new(%3c%3cENDOFSTRING)%0axe-0/0/2.0      up    up   aenet    --> ae1.0%0axe-0/0/3        up    up%0axe-0/0/3.0      up    up   aenet    --> ae1.0%0a%0axe-10/0/6.0     up    down aenet    --> ae40.0%0axe-24/0/3.0     up    down aenet    --> ae30.0%0aENDOFSTRING%0a%0atarget_column = 6%0a%0aresults = ""%0a%0af.each do |line|%0a  md = line.match(/up\s*down\s*aenet.*?-->\s*(.*)\n\z/xms)%0a%0a  if md%0a    results %3c%3c $1 %3c%3c " "%0a  end%0aend%0a%0ap results.rstrip%0a(:sourceend:)%0a%0aAlthough the number of lines shown is a lot because of including the file data, it still seemed a tad clunky.%0a%0aAfter offering the OP a quick way to do what they wanted with @@awk@@, a pure ruby method seemed necessary to follow up:%0a%0a(:source lang=ruby linenum tabwidth=4 +getcode header="first try":)%0alines = IO.readlines("data")%0alines.each do |l|%0a  if l.match(/up\s+down\s+aenet/)%0a    print l.split[5], " "%0a  end%0aend%0aprint "\n"%0a(:sourceend:)%0a%0aFirst thing, no need for the extra @@lines@@ variable:%0a%0a(:source lang=ruby linenum tabwidth=4 +getcode header="second try":)%0aIO.readlines("data").each do |l|%0a  if l.match(/up\s+down\s+aenet/)%0a    print l.split[5], " "%0a  end%0aend%0aprint "\n"%0a(:sourceend:)%0a%0aThis gets the job done, but I felt I could do better. Using the fact that you can chain calls onto objects, I thought it would compress to this:%0a%0a(:source lang=ruby linenum tabwidth=4 +getcode header="third try":)%0aoutput = []%0aIO.readlines("data").map{|l| output %3c%3c l.split[5] if l.match(/up\s+down\s+aenet/) }%0aputs output.join " "%0a(:sourceend:)%0a%0aWhy map every line with a test, when grep does something similar, then you can map the rest? Also, why have the extra output assignments at all? Why not just build what's needed and shoot it out directly? %0a%0a(:source lang=ruby linenum tabwidth=4 +getcode header="final one line version":)%0aputs IO.readlines("data").grep(/up\s+down\s+aenet/).map{|l| l.split[5]}.join " "%0a(:sourceend:)%0a%0aSo it's down to one line only, from an initial 10-ish.%0a%0aI feel like Keith Richards.%0a%0a>>comment%3c%3c%0aSummary:Taking an example from someone looking for a simple solution and iteratively refactoring it down to one line%0aParent:(Technology.)Development%0aIncludeMe:[[(Technology.)Development]]%0aCategories:[[!HowTos]]%0aTags: refactoring, ruby, oneliners%0a(:tags-hide refactoring, ruby, oneliners :)%0a>>%3c%3c%0a
time=1352266265
author:1352266265=tamara
csum:1352266265=added more versions, OP and others
diff:1352266265:1352263490:=5,9c5,14%0a%3c This was the OP's starting point:%0a%3c %0a%3c (:source lang=ruby header="Original Poster's concept:":)%0a%3c output=`cat #{file} | grep  "up    down" | grep "aenet" | awk '{print $6}'`%0a%3c puts output%0a---%0a> There were a few respondents with some longish rubyisms. After offering the OP a quick way to do what they wanted with @@awk@@, a pure ruby method seemed necessary to follow up.%0a> %0a> (:source lang=ruby linenum tabwidth=4 +getcode header="first try":)%0a> lines = IO.readlines("data")%0a> lines.each do |l|%0a>   if l.match(/up\s+down\s+aenet/)%0a>     print l.split[5], " "%0a>   end%0a> end%0a> print "\n"%0a12,22c17,22%0a%3c Really not quite getting the power of @@awk@@ here, I think.%0a%3c %0a%3c The data file we were tasked to work with:%0a%3c %0a%3c (:source header="data":)%0a%3c xe-0/0/2.0              up    up   aenet    --> ae1.0%0a%3c xe-0/0/3                up    up%0a%3c xe-0/0/3.0              up    up   aenet    --> ae1.0%0a%3c %0a%3c xe-10/0/6.0             up    down aenet    --> ae40.0%0a%3c xe-24/0/3.0             up    down aenet    --> ae30.0%0a---%0a> This gets the job done, but I felt I could do better. Using the fact that you can chain calls onto objects, I thought it would compress to this:%0a> %0a> (:source lang=ruby linenum tabwidth=4 +getcode header="second try":)%0a> output = []%0a> IO.readlines("data").map{|l| output %3c%3c l.split[5] if l.match(/up\s+down\s+aenet/) }%0a> puts output.join " "%0a25,53c25,28%0a%3c (There was more cruft, but it's really irrelevant.)%0a%3c %0a%3c There were a few respondents with some longish rubyisms:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="Another Respondent's Attempt:":)%0a%3c require 'stringio'%0a%3c %0a%3c f = StringIO.new(%3c%3cENDOFSTRING)%0a%3c xe-0/0/2.0      up    up   aenet    --> ae1.0%0a%3c xe-0/0/3        up    up%0a%3c xe-0/0/3.0      up    up   aenet    --> ae1.0%0a%3c %0a%3c xe-10/0/6.0     up    down aenet    --> ae40.0%0a%3c xe-24/0/3.0     up    down aenet    --> ae30.0%0a%3c ENDOFSTRING%0a%3c %0a%3c target_column = 6%0a%3c %0a%3c results = ""%0a%3c %0a%3c f.each do |line|%0a%3c   md = line.match(/up\s*down\s*aenet.*?-->\s*(.*)\n\z/xms)%0a%3c %0a%3c   if md%0a%3c     results %3c%3c $1 %3c%3c " "%0a%3c   end%0a%3c end%0a%3c %0a%3c p results.rstrip%0a---%0a> Well, okay, but why have the extra assignments at all? Why not just build what's needed and shoot it out directly? This took a couple of tries to get right, but now it's down to one line:%0a> %0a> (:source lang=ruby linenum tabwidth=4 +getcode header="final one line version":)%0a> puts IO.readlines("data").grep(/up\s+down\s+aenet/).map{|l| l.split[5]}.join " "%0a56,97c31%0a%3c Although the number of lines shown is a lot because of including the file data, it still seemed a tad clunky.%0a%3c %0a%3c After offering the OP a quick way to do what they wanted with @@awk@@, a pure ruby method seemed necessary to follow up:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="first try":)%0a%3c lines = IO.readlines("data")%0a%3c lines.each do |l|%0a%3c   if l.match(/up\s+down\s+aenet/)%0a%3c     print l.split[5], " "%0a%3c   end%0a%3c end%0a%3c print "\n"%0a%3c (:sourceend:)%0a%3c %0a%3c First thing, no need for the extra @@lines@@ variable:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="second try":)%0a%3c IO.readlines("data").each do |l|%0a%3c   if l.match(/up\s+down\s+aenet/)%0a%3c     print l.split[5], " "%0a%3c   end%0a%3c end%0a%3c print "\n"%0a%3c (:sourceend:)%0a%3c %0a%3c This gets the job done, but I felt I could do better. Using the fact that you can chain calls onto objects, I thought it would compress to this:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="third try":)%0a%3c output = []%0a%3c IO.readlines("data").map{|l| output %3c%3c l.split[5] if l.match(/up\s+down\s+aenet/) }%0a%3c puts output.join " "%0a%3c (:sourceend:)%0a%3c %0a%3c Why map every line with a test, when grep does something similar, then you can map the rest? Also, why have the extra output assignments at all? Why not just build what's needed and shoot it out directly? %0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="final one line version":)%0a%3c puts IO.readlines("data").grep(/up\s+down\s+aenet/).map{|l| l.split[5]}.join " "%0a%3c (:sourceend:)%0a%3c %0a%3c So it's down to one line only, from an initial 10-ish.%0a%3c %0a%3c I feel like Keith Richards.%0a---%0a> %0a
host:1352266265=71.63.215.130
author:1352263490=tamara
csum:1352263490=new page
diff:1352263490:1352263490:=1,40d0%0a%3c [[#excerpt]]%0a%3c In a recent [[post -> http://www.ruby-forum.com/topic/4407569]] on the [[ruby-talk mailing list -> http://www.ruby-forum.com/forum/ruby]], a poster asked how they could get a field from a few records out of a file on one line.%0a%3c [[#excerptend]]%0a%3c %0a%3c There were a few respondents with some longish rubyisms. After offering the OP a quick way to do what they wanted with @@awk@@, a pure ruby method seemed necessary to follow up.%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="first try":)%0a%3c lines = IO.readlines("data")%0a%3c lines.each do |l|%0a%3c   if l.match(/up\s+down\s+aenet/)%0a%3c     print l.split[5], " "%0a%3c   end%0a%3c end%0a%3c print "\n"%0a%3c (:sourceend:)%0a%3c %0a%3c This gets the job done, but I felt I could do better. Using the fact that you can chain calls onto objects, I thought it would compress to this:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="second try":)%0a%3c output = []%0a%3c IO.readlines("data").map{|l| output %3c%3c l.split[5] if l.match(/up\s+down\s+aenet/) }%0a%3c puts output.join " "%0a%3c (:sourceend:)%0a%3c %0a%3c Well, okay, but why have the extra assignments at all? Why not just build what's needed and shoot it out directly? This took a couple of tries to get right, but now it's down to one line:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 +getcode header="final one line version":)%0a%3c puts IO.readlines("data").grep(/up\s+down\s+aenet/).map{|l| l.split[5]}.join " "%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary:Taking an example from someone looking for a simple solution and iteratively refactoring it down to one line%0a%3c Parent:(Technology.)Development%0a%3c IncludeMe:[[(Technology.)Development]]%0a%3c Categories:[[!HowTos]]%0a%3c Tags: refactoring, ruby, oneliners%0a%3c (:tags-hide refactoring, ruby, oneliners :)%0a%3c >>%3c%3c%0a
host:1352263490=71.63.215.130
