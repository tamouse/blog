version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:18.0) Gecko/20100101 Firefox/18.0
author=tamara
charset=ISO-8859-1
csum=Page moved to Technology.MakeYourRubyClassesComparableAndEnumerable
ctime=1361111099
host=71.63.215.130
name=SavedArticles.MakeYourRubyClassesComparableAndEnumerableAndreasBlog20130217081008
rev=2
targets=
text=(:redirect Technology.MakeYourRubyClassesComparableAndEnumerable:)
time=1361111122
author:1361111122=tamara
csum:1361111122=Page moved to Technology.MakeYourRubyClassesComparableAndEnumerable
diff:1361111122:1361111099:=1c1,94%0a%3c (:redirect Technology.MakeYourRubyClassesComparableAndEnumerable:)%0a\ No newline at end of file%0a---%0a> (:nolinkwikiwords:)%0a> >>quote%3c%3c%0a> ! [[http://andreacfm.com:80/ | Andrea's Blog]]%0a> %0a> ! Make Your Ruby Classes Comparable and Enumerable%0a> %0a> Jul 27th, 2011 %0a> %0a> Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &ldquo;include&rdquo;. While including a module is a very large topic I focused on the opportunity to include module defined in the Ruby standard library into your class to take advantages of the methods and abilities that these modules provide. The [[http://www.ruby-doc.org/core/classes/Comparable.html | Comparable]] module in ruby define methods like [@ %3c %3c= %3c==> >= > between?@]. What if I want to achieve is making my class instances '''comparable''' so that I can ask to ruby if [@class_a > class_b@].%0a> %0a> Here an example:%0a> %0a> (:source lang=ruby linenum tabwidth=4 header="Comparable":)%0a> class Person%0a>    include Comparable%0a> %0a>    attr_reader :name%0a> %0a>    def initialize(name)%0a>      @name = name%0a>    end%0a> %0a>    def %3c=> other%0a>      self.name %3c=> other.name%0a>    end %0a> end %0a> %0a> p1 = Person.new 'Andrea' %0a> p2 = Person.new 'Fabio' %0a> p3 = Person.new 'Luigi' %0a> %0a> p p1 %3c p2 #true %0a> p p2 > p1 #false%0a> (:sourceend:)%0a> %0a> %0a> The Person class include the module Comparable and implements one single method (&lt;=&gt;). This methods is used by the Comparable module to perform the logic of any of the operator that the module provide.In the example I say to the Person class to compare instances through the @name attribute. But we even gain more functionalities. Once that our classes are able to be compared they are also able to be sorted if placed inside an array. Amazing!!!%0a> %0a> (:source lang=ruby linenum tabwidth=4 -getcode header="sorting":)%0a> [p2,p3,p1].sort #[#%3cPerson:0x104f09d80 @name="Andrea">, #%3cPerson:0x104f09d30 @name="Fabio">, #%3cPerson:0x104f09ce0 @name="Luigi">]%0a> (:sourceend:)%0a> %0a> But what if I want to find Persons by name?? Then we can use for this purpose the [[http://www.ruby-doc.org/core/classes/Enumerable.html | Enumerable]] module. What we can do is to create a custom PersonEnumerator class like this:%0a> %0a> (:source lang=ruby linenum tabwidth=4 header="Enumerable":)%0a> class PersonEnumerator%0a>    include Enumerable%0a> %0a>    attr_reader :persons%0a> %0a>    def initialize(persons)%0a>      @persons = persons%0a>    end%0a> %0a>    def each &block%0a>      @persons.each do |person|%0a>        if block_given?%0a>          block.call person%0a>        else%0a>          yield person%0a>        end%0a>      end%0a>    end%0a> end %0a> %0a> en = PersonEnumerator.new [p1,p2,p3] %0a> p en.find {|person| person.name == 'Andrea'} #%3cPerson:0x10e61d4d8 @name="Andrea">%0a> (:sourceend:)%0a> %0a> Including the Enumerable module and implementing the each method we gain most of the many methods that the module expose. In our example I '''find''' a person object passing a block that filters each Person by name.%0a> %0a> The mixin technique applied to the ruby standard library is very powerful. Your code code gets more elegant and more '''Ruby Way''' for you to maintain and for your collaborator to read and understand%0a> %0a> Ruby amazes me any day more!%0a> %0a> Posted by Andrea Campolonghi Jul 27th, 2011  [[http://andreacfm.com:80/blog/categories/ruby/ | Ruby]]%0a> %0a> Copyright &copy; 2013 - Andrea Campolonghi - Powered by [[http://octopress.org | Octopress]]%0a> >>%3c%3c%0a> (:linkwikiwords:)%0a> %0a> >>comment%3c%3c%0a> Summary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &#8220;include&#8221 &hellip;%0a> Tags: ruby, Comparable, Enumerable%0a> (:tags-hide ruby, Comparable, Enumerable:)%0a> (:title Make your ruby classes Comparable and Enumerable - Andrea's Blog:)%0a> Source: http://andreacfm.com/2011/07/27/make-your-ruby-classes-comparable-and-enumerable/%0a> Parent: (Technology.)Ruby%0a> includeme: [[Technology.Ruby]]%0a> Categories:[[!Articles]]%0a> >>%3c%3c%0a> %0a> Page saved at: Sun, 17 Feb 2013 08:10:08 -0600%0a> %0a
host:1361111122=71.63.215.130
author:1361111099=tamara
diff:1361111099:1361111099:=1,94d0%0a%3c (:nolinkwikiwords:)%0a%3c >>quote%3c%3c%0a%3c ! [[http://andreacfm.com:80/ | Andrea's Blog]]%0a%3c %0a%3c ! Make Your Ruby Classes Comparable and Enumerable%0a%3c %0a%3c Jul 27th, 2011 %0a%3c %0a%3c Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &ldquo;include&rdquo;. While including a module is a very large topic I focused on the opportunity to include module defined in the Ruby standard library into your class to take advantages of the methods and abilities that these modules provide. The [[http://www.ruby-doc.org/core/classes/Comparable.html | Comparable]] module in ruby define methods like [@ %3c %3c= %3c==> >= > between?@]. What if I want to achieve is making my class instances '''comparable''' so that I can ask to ruby if [@class_a > class_b@].%0a%3c %0a%3c Here an example:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="Comparable":)%0a%3c class Person%0a%3c    include Comparable%0a%3c %0a%3c    attr_reader :name%0a%3c %0a%3c    def initialize(name)%0a%3c      @name = name%0a%3c    end%0a%3c %0a%3c    def %3c=> other%0a%3c      self.name %3c=> other.name%0a%3c    end %0a%3c end %0a%3c %0a%3c p1 = Person.new 'Andrea' %0a%3c p2 = Person.new 'Fabio' %0a%3c p3 = Person.new 'Luigi' %0a%3c %0a%3c p p1 %3c p2 #true %0a%3c p p2 > p1 #false%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c The Person class include the module Comparable and implements one single method (&lt;=&gt;). This methods is used by the Comparable module to perform the logic of any of the operator that the module provide.In the example I say to the Person class to compare instances through the @name attribute. But we even gain more functionalities. Once that our classes are able to be compared they are also able to be sorted if placed inside an array. Amazing!!!%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 -getcode header="sorting":)%0a%3c [p2,p3,p1].sort #[#%3cPerson:0x104f09d80 @name="Andrea">, #%3cPerson:0x104f09d30 @name="Fabio">, #%3cPerson:0x104f09ce0 @name="Luigi">]%0a%3c (:sourceend:)%0a%3c %0a%3c But what if I want to find Persons by name?? Then we can use for this purpose the [[http://www.ruby-doc.org/core/classes/Enumerable.html | Enumerable]] module. What we can do is to create a custom PersonEnumerator class like this:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="Enumerable":)%0a%3c class PersonEnumerator%0a%3c    include Enumerable%0a%3c %0a%3c    attr_reader :persons%0a%3c %0a%3c    def initialize(persons)%0a%3c      @persons = persons%0a%3c    end%0a%3c %0a%3c    def each &block%0a%3c      @persons.each do |person|%0a%3c        if block_given?%0a%3c          block.call person%0a%3c        else%0a%3c          yield person%0a%3c        end%0a%3c      end%0a%3c    end%0a%3c end %0a%3c %0a%3c en = PersonEnumerator.new [p1,p2,p3] %0a%3c p en.find {|person| person.name == 'Andrea'} #%3cPerson:0x10e61d4d8 @name="Andrea">%0a%3c (:sourceend:)%0a%3c %0a%3c Including the Enumerable module and implementing the each method we gain most of the many methods that the module expose. In our example I '''find''' a person object passing a block that filters each Person by name.%0a%3c %0a%3c The mixin technique applied to the ruby standard library is very powerful. Your code code gets more elegant and more '''Ruby Way''' for you to maintain and for your collaborator to read and understand%0a%3c %0a%3c Ruby amazes me any day more!%0a%3c %0a%3c Posted by Andrea Campolonghi Jul 27th, 2011  [[http://andreacfm.com:80/blog/categories/ruby/ | Ruby]]%0a%3c %0a%3c Copyright &copy; 2013 - Andrea Campolonghi - Powered by [[http://octopress.org | Octopress]]%0a%3c >>%3c%3c%0a%3c (:linkwikiwords:)%0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &#8220;include&#8221 &hellip;%0a%3c Tags: ruby, Comparable, Enumerable%0a%3c (:tags-hide ruby, Comparable, Enumerable:)%0a%3c (:title Make your ruby classes Comparable and Enumerable - Andrea's Blog:)%0a%3c Source: http://andreacfm.com/2011/07/27/make-your-ruby-classes-comparable-and-enumerable/%0a%3c Parent: (Technology.)Ruby%0a%3c includeme: [[Technology.Ruby]]%0a%3c Categories:[[!Articles]]%0a%3c >>%3c%3c%0a%3c %0a%3c Page saved at: Sun, 17 Feb 2013 08:10:08 -0600%0a%3c %0a
host:1361111099=71.63.215.130
