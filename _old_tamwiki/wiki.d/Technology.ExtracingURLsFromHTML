version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.95 Safari/537.11
author=tamara
charset=ISO-8859-1
csum=new page
ctime=1354915301
host=75.144.38.217
name=Technology.ExtracingURLsFromHTML
rev=1
targets=Technology.ExtracingURLsFromHTML,Technology.Languages,Technology.IncludeMe,Category.HowTos
text=[[#excerpt]]%0aExtracting URLs from an HTML file has been a common enough task that it's been written about all over.%0aHere, I'm taking it a little further, comparing implementations of the task in perl and ruby using modern libraries that parse HTML turning it into a tree of DOM objects, just the way your browser would do it.%0aThis makes extraction and subsequent processing much simpler than older methods of building parser callbacks, or just using regexps to parse the file.%0a[[#excerptend]]%0a%0a!! Use of Modern Parsing Libraries%0a%0aBoth implementations make similar use of libraries written for each language that convert the HTML in a given file into something traversable by tags, ids, or classes, which makes for extremely simple, yet powerful manipulation of the DOM tree.%0a%0aThis is very much the same way jQuery handles the DOM, by offering up a very simple selection syntax to the programmer.%0a%0a(:nolinkwikiwords:)%0a%0a||border=0 center%0a||!Language ||!Library ||%0a||Ruby ||Nokogiri ||%0a||Perl ||HTML::TagParser ||%0a%0a(:linkwikiwords:)%0a%0a!! The extract method, side-by-side%0a%0a(:div style="display: inline-block; width=49%25;vertical-align:top;":)%0a(:source lang=perl linenum:)%0asub extract {%0a	my $p = shift;%0a	my @anchors = $p->getElementsByTagName('a');%0a	foreach my $anchor (@anchors) {%0a		my $href = $anchor->getAttribute('href');%0a		print "$href\n" if $href;%0a	}%0a	my @images = $p->getElementsByTagName('img');%0a	foreach my $img (@images) {%0a		my $src = $img->getAttribute('src');%0a		print "$src\n" if $src;%0a	}%0a}%0a(:sourceend:)%0a(:div style="display: inline-block; width=49%25;vertical-align:top;":)%0a(:source lang=ruby linenum:)%0adef extract (doc)%0a	doc.search("a").each do |a|%0a		puts a.attribute('href')%0a	end%0a	doc.search("img").each do |i|%0a		puts i.attribute('src')%0a	end%0aend%0a(:sourceend:)%0a(:divend:)%0a%0aThe immediate thing I note is that the size of the ruby version is like half the size of the perl version, and it looks a lot easier to read to me (granted, I understand how to read boty langauges easily). %0a%0a>>comment%3c%3c%0aSummary:Extracting URLs from HTML in two languages: Ruby and Perl%0aParent:(Technology.)Languages%0aIncludeMe:[[(Technology.)Languages]]%0aCategories:[[!HowTos]]%0aTags: perl, ruby, extract urls, examples, howtos, comparisons%0a(:tags-hide perl, ruby, extract urls, examples, howtos, comparisons :)%0a>>%3c%3c
time=1354915301
author:1354915301=tamara
csum:1354915301=new page
diff:1354915301:1354915301:=1,62d0%0a%3c [[#excerpt]]%0a%3c Extracting URLs from an HTML file has been a common enough task that it's been written about all over.%0a%3c Here, I'm taking it a little further, comparing implementations of the task in perl and ruby using modern libraries that parse HTML turning it into a tree of DOM objects, just the way your browser would do it.%0a%3c This makes extraction and subsequent processing much simpler than older methods of building parser callbacks, or just using regexps to parse the file.%0a%3c [[#excerptend]]%0a%3c %0a%3c !! Use of Modern Parsing Libraries%0a%3c %0a%3c Both implementations make similar use of libraries written for each language that convert the HTML in a given file into something traversable by tags, ids, or classes, which makes for extremely simple, yet powerful manipulation of the DOM tree.%0a%3c %0a%3c This is very much the same way jQuery handles the DOM, by offering up a very simple selection syntax to the programmer.%0a%3c %0a%3c (:nolinkwikiwords:)%0a%3c %0a%3c ||border=0 center%0a%3c ||!Language ||!Library ||%0a%3c ||Ruby ||Nokogiri ||%0a%3c ||Perl ||HTML::TagParser ||%0a%3c %0a%3c (:linkwikiwords:)%0a%3c %0a%3c !! The extract method, side-by-side%0a%3c %0a%3c (:div style="display: inline-block; width=49%25;vertical-align:top;":)%0a%3c (:source lang=perl linenum:)%0a%3c sub extract {%0a%3c 	my $p = shift;%0a%3c 	my @anchors = $p->getElementsByTagName('a');%0a%3c 	foreach my $anchor (@anchors) {%0a%3c 		my $href = $anchor->getAttribute('href');%0a%3c 		print "$href\n" if $href;%0a%3c 	}%0a%3c 	my @images = $p->getElementsByTagName('img');%0a%3c 	foreach my $img (@images) {%0a%3c 		my $src = $img->getAttribute('src');%0a%3c 		print "$src\n" if $src;%0a%3c 	}%0a%3c }%0a%3c (:sourceend:)%0a%3c (:div style="display: inline-block; width=49%25;vertical-align:top;":)%0a%3c (:source lang=ruby linenum:)%0a%3c def extract (doc)%0a%3c 	doc.search("a").each do |a|%0a%3c 		puts a.attribute('href')%0a%3c 	end%0a%3c 	doc.search("img").each do |i|%0a%3c 		puts i.attribute('src')%0a%3c 	end%0a%3c end%0a%3c (:sourceend:)%0a%3c (:divend:)%0a%3c %0a%3c The immediate thing I note is that the size of the ruby version is like half the size of the perl version, and it looks a lot easier to read to me (granted, I understand how to read boty langauges easily). %0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary:Extracting URLs from HTML in two languages: Ruby and Perl%0a%3c Parent:(Technology.)Languages%0a%3c IncludeMe:[[(Technology.)Languages]]%0a%3c Categories:[[!HowTos]]%0a%3c Tags: perl, ruby, extract urls, examples, howtos, comparisons%0a%3c (:tags-hide perl, ruby, extract urls, examples, howtos, comparisons :)%0a%3c >>%3c%3c%0a\ No newline at end of file%0a
host:1354915301=75.144.38.217
