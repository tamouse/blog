version=pmwiki-2.2.56 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
author=tamara
charset=ISO-8859-1
csum=
ctime=1386601852
host=71.63.215.130
name=Technology.CheckingForInvalidOptionsParametersInRuby
rev=1
targets=Technology.CheckingForInvalidOptionsParametersInRuby,Technology.Ruby,Technology.IncludeMe,Category.HowTos,Category.FAQ
text=>>comment%3c%3c%0aSummary: When passing in option parameters, sometimes it is useful to check that only valid options have been entered.%0aParent: (Technology.)Ruby%0aIncludeMe: [[(Technology.)Ruby]]%0aCategories: [[!HowTos]], [[!FAQ]]%0aTags: ruby, options, parameters%0a(:tags-hide ruby, options, parameters:)%0aSource: none%0aPosted: Mon Dec  9 07:04:19 2013%0a>>%3c%3c%0a%0a>>faq%3c%3c%0aQ: How do I check that only valid options have been passed to my method?%0aA: Take the difference between the option hash keys and an array of valid keys.%0a>>%3c%3c%0a%0aIn ruby, one can pass options to a method via an inferred hash by placing the options at the end of the method call parameter list:%0a%0a    my_method(object, option1: true)%0a%0afor example.%0a>>%3c%3c%0a%0a!! Define the method with an options hash%0a%0a(:source lang=ruby linenum tabwidth=2 header="method definition" :)%0adef my_method(parm1, parm2, options={})%0a  # ... (code)%0aend%0a(:sourceend:)%0a%0a%0a!! Create a constant array with the list of valid option parameters%0a%0a(:source lang=ruby linenum tabwidth=2 header="Valid method option parameters" :)%0aVALID_OPTIONS = [%0a  :option1,%0a  :option2,%0a  :option3%0a]%0a(:sourceend:)%0a%0a!! Take the array difference between the options keys and the valid options%0a%0a(:source lang=ruby linenum tabwidth=2 header="check options" :)%0aunless options.nil?%0a  invalid_options = options.keys - VALID_OPTIONS%0a  raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0aend%0a(:sourceend:)%0a%0a!! DRY it up%0a%0aIf you do this a lot (say more than twice :) ) you should consider making the check for invalid parameters a method:%0a%0a(:source lang=ruby linenum tabwidth=2 header="check_options" :)%0adef check_options(options={}, valid_options=[])%0a  raise ArgumentError.new("options not a Hash: #{options.class}") unless options.nil? || options.kind_of?(Hash)%0a  return [] if options.nil?%0a  options.keys - valid_options%0aend%0a%0adef check_options!(options, valid_options)%0a  invalid_options = check_options%0a  raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0aend%0a(:sourceend:)%0a%0aThe first method simply returns an array of invalid options, or an empty array if there were no invalid options. Note that a nil options set is valid.%0a%0aThe second method is dangerous in that it will raise an exception if invalid options were given.%0a%0aIn your method, then, you can do this:%0a%0a(:source lang=ruby linenum tabwidth=2 header="my method with options vetting" :)%0adef my_method(parm1, parm2, options={})%0a  check_options!(options, [:option1, :option2, :option3])%0a%0a  # ... (code)%0aend%0a(:sourceend:)%0a%0a!! Finally, a module%0a%0aHere is a complete module for vetting options parameters:%0a%0a(:source lang=ruby linenum tabwidth=2 header="CheckOptionsParameters Module" :) %0amodule CheckOptionsParameters%0a%0a  def check_for_invalid_options(options={},valid_options=[])%0a    raise(ArgumentError.new("options is not a Hash: #{options.class}")) unless options.nil? || options.kind_of?(Hash)%0a    valid_options = Array(valid_options)%0a    return [] if options.nil? || options.keys.empty? || valid_options.nil? || valid_options.empty?%0a    options.keys - valid_options%0a  end%0a%0a  def check_for_invalid_options!(options={},valid_options=[])%0a    invalid_options = check_option_parameters(options, valid_options)%0a    raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0a  end%0a%0a  def invalid_options?(options={}, valid_options=[])%0a    check_for_invalid_options.empty?%0a  end%0a%0a%0a  def check_for_missing_options(options={}, required_options=[])%0a    raise(ArgumentError.new("options is not a Hash: #{options.class}")) unless options.kind_of?(Hash)%0a    required_options = Array(required_options)%0a    return [] if required_options.empty?    %0a    required_options - options.keys%0a  end%0a  %0a  def check_for_missing_options!(options={}, required_options=[])%0a    missing_options = check_for_missing_options(options, required_options)%0a    raise "Required options missing: #{missing_options}" unless missing_options.empty?%0a  end%0a%0a  def missing_options?(options={}, require_options=[])%0a    check_for_missing_options(options, require_options).empty?%0a  end%0a%0aend%0a(:sourceend:)
time=1386601852
author:1386601852=tamara
diff:1386601852:1386601852:=1,124d0%0a%3c >>comment%3c%3c%0a%3c Summary: When passing in option parameters, sometimes it is useful to check that only valid options have been entered.%0a%3c Parent: (Technology.)Ruby%0a%3c IncludeMe: [[(Technology.)Ruby]]%0a%3c Categories: [[!HowTos]], [[!FAQ]]%0a%3c Tags: ruby, options, parameters%0a%3c (:tags-hide ruby, options, parameters:)%0a%3c Source: none%0a%3c Posted: Mon Dec  9 07:04:19 2013%0a%3c >>%3c%3c%0a%3c %0a%3c >>faq%3c%3c%0a%3c Q: How do I check that only valid options have been passed to my method?%0a%3c A: Take the difference between the option hash keys and an array of valid keys.%0a%3c >>%3c%3c%0a%3c %0a%3c In ruby, one can pass options to a method via an inferred hash by placing the options at the end of the method call parameter list:%0a%3c %0a%3c     my_method(object, option1: true)%0a%3c %0a%3c for example.%0a%3c >>%3c%3c%0a%3c %0a%3c !! Define the method with an options hash%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="method definition" :)%0a%3c def my_method(parm1, parm2, options={})%0a%3c   # ... (code)%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c !! Create a constant array with the list of valid option parameters%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="Valid method option parameters" :)%0a%3c VALID_OPTIONS = [%0a%3c   :option1,%0a%3c   :option2,%0a%3c   :option3%0a%3c ]%0a%3c (:sourceend:)%0a%3c %0a%3c !! Take the array difference between the options keys and the valid options%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="check options" :)%0a%3c unless options.nil?%0a%3c   invalid_options = options.keys - VALID_OPTIONS%0a%3c   raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c !! DRY it up%0a%3c %0a%3c If you do this a lot (say more than twice :) ) you should consider making the check for invalid parameters a method:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="check_options" :)%0a%3c def check_options(options={}, valid_options=[])%0a%3c   raise ArgumentError.new("options not a Hash: #{options.class}") unless options.nil? || options.kind_of?(Hash)%0a%3c   return [] if options.nil?%0a%3c   options.keys - valid_options%0a%3c end%0a%3c %0a%3c def check_options!(options, valid_options)%0a%3c   invalid_options = check_options%0a%3c   raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c The first method simply returns an array of invalid options, or an empty array if there were no invalid options. Note that a nil options set is valid.%0a%3c %0a%3c The second method is dangerous in that it will raise an exception if invalid options were given.%0a%3c %0a%3c In your method, then, you can do this:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="my method with options vetting" :)%0a%3c def my_method(parm1, parm2, options={})%0a%3c   check_options!(options, [:option1, :option2, :option3])%0a%3c %0a%3c   # ... (code)%0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c !! Finally, a module%0a%3c %0a%3c Here is a complete module for vetting options parameters:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=2 header="CheckOptionsParameters Module" :) %0a%3c module CheckOptionsParameters%0a%3c %0a%3c   def check_for_invalid_options(options={},valid_options=[])%0a%3c     raise(ArgumentError.new("options is not a Hash: #{options.class}")) unless options.nil? || options.kind_of?(Hash)%0a%3c     valid_options = Array(valid_options)%0a%3c     return [] if options.nil? || options.keys.empty? || valid_options.nil? || valid_options.empty?%0a%3c     options.keys - valid_options%0a%3c   end%0a%3c %0a%3c   def check_for_invalid_options!(options={},valid_options=[])%0a%3c     invalid_options = check_option_parameters(options, valid_options)%0a%3c     raise "Invalid options given: #{invalid_options}" unless invalid_options.empty?%0a%3c   end%0a%3c %0a%3c   def invalid_options?(options={}, valid_options=[])%0a%3c     check_for_invalid_options.empty?%0a%3c   end%0a%3c %0a%3c %0a%3c   def check_for_missing_options(options={}, required_options=[])%0a%3c     raise(ArgumentError.new("options is not a Hash: #{options.class}")) unless options.kind_of?(Hash)%0a%3c     required_options = Array(required_options)%0a%3c     return [] if required_options.empty?    %0a%3c     required_options - options.keys%0a%3c   end%0a%3c   %0a%3c   def check_for_missing_options!(options={}, required_options=[])%0a%3c     missing_options = check_for_missing_options(options, required_options)%0a%3c     raise "Required options missing: #{missing_options}" unless missing_options.empty?%0a%3c   end%0a%3c %0a%3c   def missing_options?(options={}, require_options=[])%0a%3c     check_for_missing_options(options, require_options).empty?%0a%3c   end%0a%3c %0a%3c end%0a%3c (:sourceend:)%0a\ No newline at end of file%0a
host:1386601852=71.63.215.130
