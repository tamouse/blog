version=pmwiki-2.2.56 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
author=tamara
charset=ISO-8859-1
csum=pointer to using Enumerator instead of Enumerable
ctime=1361111099
host=173.8.101.94
name=Technology.MakeYourRubyClassesComparableAndEnumerable
rev=5
targets=Technology.MakeYourRubyClassesComparableAndEnumerable,Technology.HowToUsingEnumeratorInsteadOfEnumerable,Technology.Ruby,Category.Articles
text=!! Update:%0a%0aWhile the below is useful and interesting in many cases, making a class [@Enumerable@] may be overkill in many cases. You can also simply return an [@Enumerator@] for the [@:each@] method to get much the same capability. As outlined in http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/,%0ause of [@Enumerable@] should be limited to classes which are actually collections.%0a%0a>>quote%3c%3c%0aIn such case I prefer to go Java-way and provide external Enumerator for those who need to call one of the many useful Enumerable methods on the collection. I think that we need to ask ourselves a question: Is that class a collection?. If it really is then it absolutely makes sense to include Enumerable. If however it is not a collection, but rather a class which happens contain something else, or providing a collection, well then maybe external Enumerator is your solution.%0a>>%3c%3c%0a%0aSee [[(Technology.)HowToUsingEnumeratorInsteadOfEnumerable]].%0a%0a%0a(:nolinkwikiwords:)%0a>>quote%3c%3c%0a! [[http://andreacfm.com:80/ | Andrea's Blog]]%0a%0a! Make Your Ruby Classes Comparable and Enumerable%0a%0aJul 27th, 2011 %0a%0aSomething very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &ldquo;include&rdquo;. While including a module is a very large topic I focused on the opportunity to include module defined in the Ruby standard library into your class to take advantages of the methods and abilities that these modules provide. The [[http://www.ruby-doc.org/core/classes/Comparable.html | Comparable]] module in ruby define methods like [@ %3c %3c= %3c==> >= > between?@]. What if I want to achieve is making my class instances '''comparable''' so that I can ask to ruby if [@class_a > class_b@].%0a%0aHere an example:%0a%0a(:source lang=ruby linenum tabwidth=4 header="Comparable":)%0aclass Person%0a   include Comparable%0a%0a   attr_reader :name%0a%0a   def initialize(name)%0a     @name = name%0a   end%0a%0a   def %3c=> other%0a     self.name %3c=> other.name%0a   end %0aend %0a%0ap1 = Person.new 'Andrea' %0ap2 = Person.new 'Fabio' %0ap3 = Person.new 'Luigi' %0a%0ap p1 %3c p2 #true %0ap p2 > p1 #false%0a(:sourceend:)%0a%0a%0aThe Person class include the module Comparable and implements one single method (&lt;=&gt;). This methods is used by the Comparable module to perform the logic of any of the operator that the module provide.In the example I say to the Person class to compare instances through the @name attribute. But we even gain more functionalities. Once that our classes are able to be compared they are also able to be sorted if placed inside an array. Amazing!!!%0a%0a(:source lang=ruby linenum tabwidth=4 -getcode header="sorting":)%0a[p2,p3,p1].sort #[#%3cPerson:0x104f09d80 @name="Andrea">, #%3cPerson:0x104f09d30 @name="Fabio">, #%3cPerson:0x104f09ce0 @name="Luigi">]%0a(:sourceend:)%0a%0aBut what if I want to find Persons by name?? Then we can use for this purpose the [[http://www.ruby-doc.org/core/classes/Enumerable.html | Enumerable]] module. What we can do is to create a custom PersonEnumerator class like this:%0a%0a(:source lang=ruby linenum tabwidth=4 header="Enumerable":)%0aclass PersonEnumerator%0a   include Enumerable%0a%0a   attr_reader :persons%0a%0a   def initialize(persons)%0a     @persons = persons%0a   end%0a%0a   def each &block%0a     @persons.each do |person|%0a       if block_given?%0a         block.call person%0a       else%0a         yield person%0a       end%0a     end%0a   end%0aend %0a%0aen = PersonEnumerator.new [p1,p2,p3] %0ap en.find {|person| person.name == 'Andrea'} #%3cPerson:0x10e61d4d8 @name="Andrea">%0a(:sourceend:)%0a%0aIncluding the Enumerable module and implementing the each method we gain most of the many methods that the module expose. In our example I '''find''' a person object passing a block that filters each Person by name.%0a%0aThe mixin technique applied to the ruby standard library is very powerful. Your code code gets more elegant and more '''Ruby Way''' for you to maintain and for your collaborator to read and understand%0a%0aRuby amazes me any day more!%0a%0aPosted by Andrea Campolonghi Jul 27th, 2011  [[http://andreacfm.com:80/blog/categories/ruby/ | Ruby]]%0a%0aCopyright &copy; 2013 - Andrea Campolonghi - Powered by [[http://octopress.org | Octopress]]%0a>>%3c%3c%0a(:linkwikiwords:)%0a%0a!! And a fun example, combined with using Struct%0a%0a(:source lang=ruby linenum header="struct_play":)%0aclass MyClass %3c Struct.new :stuff, :and, :nonsense%0a  def initialize%0a    self.stuff = Array.new%0a    self.and = Hash.new%0a    self.nonsense = String.new%0a  end%0a  %0a  include Enumerable%0a%0a  # Defining the #each method gives a whole lot of other goodies coming from Enumerable%0a  def each &block%0a    self.stuff.each do |s|%0a      if block_given?%0a        block.call s%0a      else%0a        yield s%0a      end%0a    end%0a  end%0a%0a  # This little ditty appends objects to the stuff inst_var so you can do%0a  # neat things like:%0a  #%0a  #     c %3c%3c 1 %3c%3c 'a' %3c%3c :one%0a  def %3c%3c obj%0a    self.stuff %3c%3c obj%0a  end%0a  %0a  # Give a nice output for the object%0a  def to_s%0a    "#{self.nonsense.to_s} #{self.and.inspect} #{self.stuff.inspect}"%0a  end%0a  %0a  # Provides a means of getting at both containers in the class.%0a  # Integer values for idx simply return the value at stuff[idx] while%0a  # Non-Integer values act as keys to the hash and.%0a  def [] idx%0a    case idx%0a    when Integer%0a      self.stuff[idx]%0a    else%0a      self.and[idx]%0a    end%0a  end%0a%0a  # Counterpart to the above, this is the setter%0a  def []= idx, obj%0a    case idx%0a    when Integer%0a      self.stuff[idx]=obj%0a    else%0a      self.and[idx]=obj%0a    end%0a  end%0a  %0a  # Makes this class's objects comparable, so they can be sorted%0a  # and other neat tricks.%0a  include Comparable%0a%0a  # The basic comparison operator.%0a  # In this case, it's just the nonsense content that's being compared.%0a  def %3c=> other%0a    self.nonsense %3c=> other.nonsense%0a  end%0a%0aend%0a(:sourceend:)%0a%0aWhich lets me do fun things like this:%0a%0a(:source lang=text:)%0airb(main):001:0> load 'struct_play.rb'%0atrue%0airb(main):002:0> c = MyClass.new%0a#%3cstruct MyClass stuff=[], and={}, nonsense="">%0airb(main):003:0> c %3c%3c 1 %3c%3c 'a' %3c%3c :one%0a[1, "a", :one]%0airb(main):004:0> c.nonsense = "This is nonsense"%0a"This is nonsense"%0airb(main):005:0> c[:a] = %25{some words of dissent}%0a"some words of dissent"%0airb(main):006:0> c['wax'] = %25w{wax on wax off}%0a["wax", "on", "wax", "off"]%0airb(main):007:0> puts c.to_s%0aThis is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0anil%0airb(main):008:0> c1 = MyClass.new%0a#%3cstruct MyClass stuff=[], and={}, nonsense="">%0airb(main):009:0> c1.nonsense = "Another fine mess"%0a"Another fine mess"%0airb(main):010:0> c2 = MyClass.new%0a#%3cstruct MyClass stuff=[], and={}, nonsense="">%0airb(main):011:0> c2.nonsense = "the bees knees"%0a"the bees knees"%0airb(main):012:0> [c,c1,c2].sort%0a[#%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0airb(main):013:0> [c,c1,c2].each {|x| puts x}%0aThis is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0aAnother fine mess {} []%0athe bees knees {} []%0a[#%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0airb(main):014:0> [c,c1,c2].sort.each {|x| puts x}%0aAnother fine mess {} []%0aThis is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0athe bees knees {} []%0a[#%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0airb(main):015:0> c.and.keys%0a[:a, "wax"]%0airb(main):016:0> c.keys%0aNoMethodError: undefined method `keys' for #%3cMyClass:0x97f50f4>%0a	from (irb):16%0a	from /home/tamara/.rvm/rubies/ruby-2.0.0-p195/bin/irb:13:in `%3cmain>'%0airb(main):017:0> %0a(:sourceend:)%0a%0a%0a%0a%0a>>comment%3c%3c%0aSummary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement 'include'%0aTags: ruby, Comparable, Enumerable%0a(:tags-hide ruby, Comparable, Enumerable:)%0a(:title Make your ruby classes Comparable and Enumerable - Andrea's Blog:)%0aSource: http://andreacfm.com/2011/07/27/make-your-ruby-classes-comparable-and-enumerable/%0aParent: (Technology.)Ruby%0aincludeme: [[Technology.Ruby]]%0aCategories:[[!Articles]]%0a>>%3c%3c%0a%0aPage saved at: Sun, 17 Feb 2013 08:10:08 -0600%0a
time=1389635434
title=Make your ruby classes Comparable and Enumerable - Andrea's Blog
author:1389635434=tamara
csum:1389635434=pointer to using Enumerator instead of Enumerable
diff:1389635434:1370496436:=1,5c1%0a%3c !! Update:%0a%3c %0a%3c While the below is useful and interesting in many cases, making a class [@Enumerable@] may be overkill in many cases. You can also simply return an [@Enumerator@] for the [@:each@] method to get much the same capability. As outlined in http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/,%0a%3c use of [@Enumerable@] should be limited to classes which are actually collections.%0a%3c %0a---%0a> (:nolinkwikiwords:)%0a7,14d2%0a%3c In such case I prefer to go Java-way and provide external Enumerator for those who need to call one of the many useful Enumerable methods on the collection. I think that we need to ask ourselves a question: Is that class a collection?. If it really is then it absolutely makes sense to include Enumerable. If however it is not a collection, but rather a class which happens contain something else, or providing a collection, well then maybe external Enumerator is your solution.%0a%3c >>%3c%3c%0a%3c %0a%3c See [[(Technology.)HowToUsingEnumeratorInsteadOfEnumerable]].%0a%3c %0a%3c %0a%3c (:nolinkwikiwords:)%0a%3c >>quote%3c%3c%0a226a215%0a> %0a
host:1389635434=173.8.101.94
author:1370496436=tamara
csum:1370496436=add an example of my own, combining Comparable and Enumerable
diff:1370496436:1364159825:=81,201d80%0a%3c %0a%3c !! And a fun example, combined with using Struct%0a%3c %0a%3c (:source lang=ruby linenum header="struct_play":)%0a%3c class MyClass %3c Struct.new :stuff, :and, :nonsense%0a%3c   def initialize%0a%3c     self.stuff = Array.new%0a%3c     self.and = Hash.new%0a%3c     self.nonsense = String.new%0a%3c   end%0a%3c   %0a%3c   include Enumerable%0a%3c %0a%3c   # Defining the #each method gives a whole lot of other goodies coming from Enumerable%0a%3c   def each &block%0a%3c     self.stuff.each do |s|%0a%3c       if block_given?%0a%3c         block.call s%0a%3c       else%0a%3c         yield s%0a%3c       end%0a%3c     end%0a%3c   end%0a%3c %0a%3c   # This little ditty appends objects to the stuff inst_var so you can do%0a%3c   # neat things like:%0a%3c   #%0a%3c   #     c %3c%3c 1 %3c%3c 'a' %3c%3c :one%0a%3c   def %3c%3c obj%0a%3c     self.stuff %3c%3c obj%0a%3c   end%0a%3c   %0a%3c   # Give a nice output for the object%0a%3c   def to_s%0a%3c     "#{self.nonsense.to_s} #{self.and.inspect} #{self.stuff.inspect}"%0a%3c   end%0a%3c   %0a%3c   # Provides a means of getting at both containers in the class.%0a%3c   # Integer values for idx simply return the value at stuff[idx] while%0a%3c   # Non-Integer values act as keys to the hash and.%0a%3c   def [] idx%0a%3c     case idx%0a%3c     when Integer%0a%3c       self.stuff[idx]%0a%3c     else%0a%3c       self.and[idx]%0a%3c     end%0a%3c   end%0a%3c %0a%3c   # Counterpart to the above, this is the setter%0a%3c   def []= idx, obj%0a%3c     case idx%0a%3c     when Integer%0a%3c       self.stuff[idx]=obj%0a%3c     else%0a%3c       self.and[idx]=obj%0a%3c     end%0a%3c   end%0a%3c   %0a%3c   # Makes this class's objects comparable, so they can be sorted%0a%3c   # and other neat tricks.%0a%3c   include Comparable%0a%3c %0a%3c   # The basic comparison operator.%0a%3c   # In this case, it's just the nonsense content that's being compared.%0a%3c   def %3c=> other%0a%3c     self.nonsense %3c=> other.nonsense%0a%3c   end%0a%3c %0a%3c end%0a%3c (:sourceend:)%0a%3c %0a%3c Which lets me do fun things like this:%0a%3c %0a%3c (:source lang=text:)%0a%3c irb(main):001:0> load 'struct_play.rb'%0a%3c true%0a%3c irb(main):002:0> c = MyClass.new%0a%3c #%3cstruct MyClass stuff=[], and={}, nonsense="">%0a%3c irb(main):003:0> c %3c%3c 1 %3c%3c 'a' %3c%3c :one%0a%3c [1, "a", :one]%0a%3c irb(main):004:0> c.nonsense = "This is nonsense"%0a%3c "This is nonsense"%0a%3c irb(main):005:0> c[:a] = %25{some words of dissent}%0a%3c "some words of dissent"%0a%3c irb(main):006:0> c['wax'] = %25w{wax on wax off}%0a%3c ["wax", "on", "wax", "off"]%0a%3c irb(main):007:0> puts c.to_s%0a%3c This is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0a%3c nil%0a%3c irb(main):008:0> c1 = MyClass.new%0a%3c #%3cstruct MyClass stuff=[], and={}, nonsense="">%0a%3c irb(main):009:0> c1.nonsense = "Another fine mess"%0a%3c "Another fine mess"%0a%3c irb(main):010:0> c2 = MyClass.new%0a%3c #%3cstruct MyClass stuff=[], and={}, nonsense="">%0a%3c irb(main):011:0> c2.nonsense = "the bees knees"%0a%3c "the bees knees"%0a%3c irb(main):012:0> [c,c1,c2].sort%0a%3c [#%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0a%3c irb(main):013:0> [c,c1,c2].each {|x| puts x}%0a%3c This is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0a%3c Another fine mess {} []%0a%3c the bees knees {} []%0a%3c [#%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0a%3c irb(main):014:0> [c,c1,c2].sort.each {|x| puts x}%0a%3c Another fine mess {} []%0a%3c This is nonsense {:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]} [1, "a", :one]%0a%3c the bees knees {} []%0a%3c [#%3cstruct MyClass stuff=[], and={}, nonsense="Another fine mess">, #%3cstruct MyClass stuff=[1, "a", :one], and={:a=>"some words of dissent", "wax"=>["wax", "on", "wax", "off"]}, nonsense="This is nonsense">, #%3cstruct MyClass stuff=[], and={}, nonsense="the bees knees">]%0a%3c irb(main):015:0> c.and.keys%0a%3c [:a, "wax"]%0a%3c irb(main):016:0> c.keys%0a%3c NoMethodError: undefined method `keys' for #%3cMyClass:0x97f50f4>%0a%3c 	from (irb):16%0a%3c 	from /home/tamara/.rvm/rubies/ruby-2.0.0-p195/bin/irb:13:in `%3cmain>'%0a%3c irb(main):017:0> %0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c %0a
host:1370496436=71.63.215.130
author:1364159825=tamara
csum:1364159825=puncuation on summary
diff:1364159825:1361111122:minor=83c83%0a%3c Summary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement 'include'%0a---%0a> Summary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &#8220;include&#8221 &hellip;%0a
host:1364159825=71.63.215.130
author:1361111122=tamara
csum:1361111122=Page moved to Technology.MakeYourRubyClassesComparableAndEnumerable from SavedArticles.MakeYourRubyClassesComparableAndEnumerableAndreasBlog20130217081008
diff:1361111122:1361111099:=
host:1361111122=71.63.215.130
author:1361111099=tamara
diff:1361111099:1361111099:=1,94d0%0a%3c (:nolinkwikiwords:)%0a%3c >>quote%3c%3c%0a%3c ! [[http://andreacfm.com:80/ | Andrea's Blog]]%0a%3c %0a%3c ! Make Your Ruby Classes Comparable and Enumerable%0a%3c %0a%3c Jul 27th, 2011 %0a%3c %0a%3c Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &ldquo;include&rdquo;. While including a module is a very large topic I focused on the opportunity to include module defined in the Ruby standard library into your class to take advantages of the methods and abilities that these modules provide. The [[http://www.ruby-doc.org/core/classes/Comparable.html | Comparable]] module in ruby define methods like [@ %3c %3c= %3c==> >= > between?@]. What if I want to achieve is making my class instances '''comparable''' so that I can ask to ruby if [@class_a > class_b@].%0a%3c %0a%3c Here an example:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="Comparable":)%0a%3c class Person%0a%3c    include Comparable%0a%3c %0a%3c    attr_reader :name%0a%3c %0a%3c    def initialize(name)%0a%3c      @name = name%0a%3c    end%0a%3c %0a%3c    def %3c=> other%0a%3c      self.name %3c=> other.name%0a%3c    end %0a%3c end %0a%3c %0a%3c p1 = Person.new 'Andrea' %0a%3c p2 = Person.new 'Fabio' %0a%3c p3 = Person.new 'Luigi' %0a%3c %0a%3c p p1 %3c p2 #true %0a%3c p p2 > p1 #false%0a%3c (:sourceend:)%0a%3c %0a%3c %0a%3c The Person class include the module Comparable and implements one single method (&lt;=&gt;). This methods is used by the Comparable module to perform the logic of any of the operator that the module provide.In the example I say to the Person class to compare instances through the @name attribute. But we even gain more functionalities. Once that our classes are able to be compared they are also able to be sorted if placed inside an array. Amazing!!!%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 -getcode header="sorting":)%0a%3c [p2,p3,p1].sort #[#%3cPerson:0x104f09d80 @name="Andrea">, #%3cPerson:0x104f09d30 @name="Fabio">, #%3cPerson:0x104f09ce0 @name="Luigi">]%0a%3c (:sourceend:)%0a%3c %0a%3c But what if I want to find Persons by name?? Then we can use for this purpose the [[http://www.ruby-doc.org/core/classes/Enumerable.html | Enumerable]] module. What we can do is to create a custom PersonEnumerator class like this:%0a%3c %0a%3c (:source lang=ruby linenum tabwidth=4 header="Enumerable":)%0a%3c class PersonEnumerator%0a%3c    include Enumerable%0a%3c %0a%3c    attr_reader :persons%0a%3c %0a%3c    def initialize(persons)%0a%3c      @persons = persons%0a%3c    end%0a%3c %0a%3c    def each &block%0a%3c      @persons.each do |person|%0a%3c        if block_given?%0a%3c          block.call person%0a%3c        else%0a%3c          yield person%0a%3c        end%0a%3c      end%0a%3c    end%0a%3c end %0a%3c %0a%3c en = PersonEnumerator.new [p1,p2,p3] %0a%3c p en.find {|person| person.name == 'Andrea'} #%3cPerson:0x10e61d4d8 @name="Andrea">%0a%3c (:sourceend:)%0a%3c %0a%3c Including the Enumerable module and implementing the each method we gain most of the many methods that the module expose. In our example I '''find''' a person object passing a block that filters each Person by name.%0a%3c %0a%3c The mixin technique applied to the ruby standard library is very powerful. Your code code gets more elegant and more '''Ruby Way''' for you to maintain and for your collaborator to read and understand%0a%3c %0a%3c Ruby amazes me any day more!%0a%3c %0a%3c Posted by Andrea Campolonghi Jul 27th, 2011  [[http://andreacfm.com:80/blog/categories/ruby/ | Ruby]]%0a%3c %0a%3c Copyright &copy; 2013 - Andrea Campolonghi - Powered by [[http://octopress.org | Octopress]]%0a%3c >>%3c%3c%0a%3c (:linkwikiwords:)%0a%3c %0a%3c >>comment%3c%3c%0a%3c Summary: Something very cool in ruby are mixins. As the word says mixin is a technique to mixed a module into a class using the statement &#8220;include&#8221 &hellip;%0a%3c Tags: ruby, Comparable, Enumerable%0a%3c (:tags-hide ruby, Comparable, Enumerable:)%0a%3c (:title Make your ruby classes Comparable and Enumerable - Andrea's Blog:)%0a%3c Source: http://andreacfm.com/2011/07/27/make-your-ruby-classes-comparable-and-enumerable/%0a%3c Parent: (Technology.)Ruby%0a%3c includeme: [[Technology.Ruby]]%0a%3c Categories:[[!Articles]]%0a%3c >>%3c%3c%0a%3c %0a%3c Page saved at: Sun, 17 Feb 2013 08:10:08 -0600%0a%3c %0a
host:1361111099=71.63.215.130
