version=pmwiki-2.2.43 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:17.0) Gecko/17.0 Firefox/17.0
author=tamara
charset=ISO-8859-1
csum=new page
ctime=1354180406
host=71.63.215.130
name=Technology.ArubaCommandLineTestingGem
rev=1
targets=Technology.Ruby,Technology.IncludeMe,Category.HowTos,Technology.Cucumber,Technology.RubyOnRails
text=>>comment%3c%3c%0aSummary:aruba is a ruby gem that in conjunction with cucumber makes testing ruby command line applications much easier%0aParent:(Technology.)Ruby%0aIncludeMe:[[(Technology.)Ruby]]%0aCategories:[[!HowTos]]%0aTags: ruby, command line, testing, cucumber, aruba%0a(:tags-hide ruby, command line, testing, cucumber, aruba :)%0a>>%3c%3c%0a%0a[[#excerpt]]%0aI have been trying to learn how to use aruba in testing a command line ruby application, as described in the [[methadone -> http://davetron5000.github.com/methadone/]] site. There seems to be little to go on out there. I was getting frustrated until I found out where the nifty steps are implmenented.%0a[[#excerptend]]%0a%0a!! Aruba, and Cucumber%0a%0a[[Cucumber]] is a great feature testing tool for [[Ruby]] applications. It is used extensively in [[RubyOnRails]] web applications, and for many gems.%0a%0aI have started to write a command line application for work and started using the methadone gem, which makes things pretty sweet. It uses cucumber and [[Aruba -> https://github.com/cucumber/aruba]] to drive the cucumber feature tests.%0a%0aThe problem was, I didn't know the step definitions, and couldn't figure out where they were. I finally, after much digging, discovered that under the gem's @@lib/aruba@@ directory, was a file called @@cucumber.rb@@ which, lo and behold, contained all the things I was looking for.%0a%0aHere is the set of defined steps from that [[file -> https://github.com/cucumber/aruba/blob/master/lib/aruba/cucumber.rb]]:%0a%0a(:source lang=text linenum -getcode:)%0aGiven /The default aruba timeout is (\d+) seconds/ do |seconds|%0a  @aruba_timeout_seconds = seconds.to_i%0aend%0a%0aGiven /^I'm using a clean gemset "([^"]*)"$/ do |gemset|%0a  use_clean_gemset(gemset)%0aend%0a%0aGiven /^a directory named "([^"]*)"$/ do |dir_name|%0a  create_dir(dir_name)%0aend%0a%0aGiven /^a file named "([^"]*)" with:$/ do |file_name, file_content|%0a  write_file(file_name, file_content)%0aend%0a%0aGiven /^a (\d+) byte file named "([^"]*)"$/ do |file_size, file_name|%0a  write_fixed_size_file(file_name, file_size.to_i)%0aend%0a%0aGiven /^an empty file named "([^"]*)"$/ do |file_name|%0a  write_file(file_name, "")%0aend%0a%0aWhen /^I write to "([^"]*)" with:$/ do |file_name, file_content|%0a  write_file(file_name, file_content)%0aend%0a%0aWhen /^I overwrite "([^"]*)" with:$/ do |file_name, file_content|%0a  overwrite_file(file_name, file_content)%0aend%0a%0aWhen /^I append to "([^"]*)" with:$/ do |file_name, file_content|%0a  append_to_file(file_name, file_content)%0aend%0a%0aWhen /^I append to "([^"]*)" with "([^"]*)"$/ do |file_name, file_content|%0a  append_to_file(file_name, file_content)%0aend%0a%0aWhen /^I remove the file "([^"]*)"$/ do |file_name|%0a  remove_file(file_name)%0aend%0a%0aWhen /^I cd to "([^"]*)"$/ do |dir|%0a  cd(dir)%0aend%0a%0aWhen /^I run "(.*)"$/ do |cmd|%0a  warn(%25{\e[35m    The /^I run "(.*)"$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a  run_simple(unescape(cmd), false)%0aend%0a%0aWhen /^I run `([^`]*)`$/ do |cmd|%0a  run_simple(unescape(cmd), false)%0aend%0a%0aWhen /^I successfully run "(.*)"$/ do |cmd|%0a  warn(%25{\e[35m    The  /^I successfully run "(.*)"$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a  run_simple(unescape(cmd))%0aend%0a%0a## I successfully run `echo -n "Hello"`%0a## I successfully run `sleep 29` for up to 30 seconds%0aWhen /^I successfully run `(.*?)`(?: for up to (\d+) seconds)?$/ do |cmd, secs|%0a  run_simple(unescape(cmd), true, secs && secs.to_i)%0aend%0a%0aWhen /^I run "([^"]*)" interactively$/ do |cmd|%0a  warn(%25{\e[35m    The /^I run "([^"]*)" interactively$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a  run_interactive(unescape(cmd))%0aend%0a%0aWhen /^I run `([^`]*)` interactively$/ do |cmd|%0a  run_interactive(unescape(cmd))%0aend%0a%0aWhen /^I type "([^"]*)"$/ do |input|%0a  type(input)%0aend%0a%0aWhen /^I wait for (?:output|stdout) to contain "([^"]*)"$/ do |expected|%0a  Timeout::timeout(exit_timeout) do%0a    loop do%0a      break if assert_partial_output_interactive(expected)%0a      sleep 0.1%0a    end%0a  end%0aend%0a%0aThen /^the output should contain "([^"]*)"$/ do |expected|%0a  assert_partial_output(expected, all_output)%0aend%0a%0aThen /^the output from "([^"]*)" should contain "([^"]*)"$/ do |cmd, expected|%0a  assert_partial_output(expected, output_from(cmd))%0aend%0a%0aThen /^the output from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a  assert_no_partial_output(unexpected, output_from(cmd))%0aend%0a%0aThen /^the output should not contain "([^"]*)"$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_output)%0aend%0a%0aThen /^the output should contain:$/ do |expected|%0a  assert_partial_output(expected, all_output)%0aend%0a%0aThen /^the output should not contain:$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_output)%0aend%0a%0a## the output should contain exactly "output"%0a## the output from `echo -n "Hello"` should contain exactly "Hello"%0aThen /^the output(?: from "(.*?)")? should contain exactly "(.*?)"$/ do |cmd, expected|%0a  assert_exact_output(expected, cmd ? output_from(cmd) : all_output)%0aend%0a%0a## the output should contain exactly:%0a## the output from `echo -n "Hello"` should contain exactly:%0aThen /^the output(?: from "(.*?)")? should contain exactly:$/ do |cmd, expected|%0a  assert_exact_output(expected, cmd ? output_from(cmd) : all_output)%0aend%0a%0a# "the output should match" allows regex in the partial_output, if%0a# you don't need regex, use "the output should contain" instead since%0a# that way, you don't have to escape regex characters that%0a# appear naturally in the output%0aThen /^the output should match \/([^\/]*)\/$/ do |expected|%0a  assert_matching_output(expected, all_output)%0aend%0a%0aThen /^the output should match:$/ do |expected|%0a  assert_matching_output(expected, all_output)%0aend%0a%0a# The previous two steps antagonists%0aThen /^the output should not match \/([^\/]*)\/$/ do |expected|%0a  assert_not_matching_output(expected, all_output)%0aend%0a%0aThen /^the output should not match:$/ do |expected|%0a  assert_not_matching_output(expected, all_output)%0aend%0a%0aThen /^the exit status should be (\d+)$/ do |exit_status|%0a  assert_exit_status(exit_status.to_i)%0aend%0a%0aThen /^the exit status should not be (\d+)$/ do |exit_status|%0a  assert_not_exit_status(exit_status.to_i)%0aend%0a%0aThen /^it should (pass|fail) with:$/ do |pass_fail, partial_output|%0a  self.__send__("assert_#{pass_fail}ing_with", partial_output)%0aend%0a%0aThen /^it should (pass|fail) with exactly:$/ do |pass_fail, exact_output|%0a  assert_exit_status_and_output(pass_fail == "pass", exact_output, true)%0aend%0a%0aThen /^it should (pass|fail) with regexp?:$/ do |pass_fail, expected|%0a  assert_matching_output(expected, all_output)%0a  assert_success(pass_fail == 'pass')%0aend%0a%0a## the stderr should contain "hello"%0a## the stderr from "echo -n 'Hello'" should contain "hello"%0a## the stderr should contain exactly:%0a## the stderr from "echo -n 'Hello'" should contain exactly:%0aThen /^the stderr(?: from "(.*?)")? should contain( exactly)? "(.*?)"$/ do |cmd, exact, expected|%0a  if exact%0a    assert_exact_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a  else%0a    assert_partial_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a  end%0aend%0a%0a## the stderr should contain:%0a## the stderr from "echo -n 'Hello'" should contain:%0a## the stderr should contain exactly:%0a## the stderr from "echo -n 'Hello'" should contain exactly:%0aThen /^the stderr(?: from "(.*?)")? should contain( exactly)?:$/ do |cmd, exact, expected|%0a  if exact%0a    assert_exact_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a  else%0a    assert_partial_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a  end%0aend%0a%0a## the stdout should contain "hello"%0a## the stdout from "echo -n 'Hello'" should contain "hello"%0a## the stdout should contain exactly:%0a## the stdout from "echo -n 'Hello'" should contain exactly:%0aThen /^the stdout(?: from "(.*?)")? should contain( exactly)? "(.*?)"$/ do |cmd, exact, expected|%0a  if exact%0a    assert_exact_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a  else%0a    assert_partial_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a  end%0aend%0a%0a## the stdout should contain:%0a## the stdout from "echo -n 'Hello'" should contain:%0a## the stdout should contain exactly:%0a## the stdout from "echo -n 'Hello'" should contain exactly:%0aThen /^the stdout(?: from "(.*?)")? should contain( exactly)?:$/ do |cmd, exact, expected|%0a  if exact%0a    assert_exact_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a  else%0a    assert_partial_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a  end%0aend%0a%0aThen /^the stderr should not contain "([^"]*)"$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_stderr)%0aend%0a%0aThen /^the stderr should not contain:$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_stderr)%0aend%0a%0aThen /^the (stderr|stdout) should not contain anything$/ do |stream_name|%0a  stream = self.send("all_#{stream_name}")%0a  stream.should be_empty%0aend%0a%0aThen /^the stdout should not contain "([^"]*)"$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_stdout)%0aend%0a%0aThen /^the stdout should not contain:$/ do |unexpected|%0a  assert_no_partial_output(unexpected, all_stdout)%0aend%0a%0aThen /^the stdout from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a  assert_no_partial_output(unexpected, stdout_from(cmd))%0aend%0a%0aThen /^the stderr from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a  assert_no_partial_output(unexpected, stderr_from(cmd))%0aend%0a%0aThen /^the file "([^"]*)" should not exist$/ do |file_name|%0a  check_file_presence([file_name], false)%0aend%0a%0aThen /^the following files should exist:$/ do |files|%0a  check_file_presence(files.raw.map{|file_row| file_row[0]}, true)%0aend%0a%0aThen /^the following files should not exist:$/ do |files|%0a  check_file_presence(files.raw.map{|file_row| file_row[0]}, false)%0aend%0a%0aThen /^a file named "([^"]*)" should exist$/ do |file|%0a  check_file_presence([file], true)%0aend%0a%0aThen /^a file named "([^"]*)" should not exist$/ do |file|%0a  check_file_presence([file], false)%0aend%0a%0aThen /^a (\d+) byte file named "([^"]*)" should exist$/ do |file_size, file_name|%0a  check_file_size([[file_name, file_size.to_i]])%0aend%0a%0aThen /^the following directories should exist:$/ do |directories|%0a  check_directory_presence(directories.raw.map{|directory_row| directory_row[0]}, true)%0aend%0a%0aThen /^the following directories should not exist:$/ do |directories|%0a  check_directory_presence(directories.raw.map{|directory_row| directory_row[0]}, false)%0aend%0a%0aThen /^a directory named "([^"]*)" should exist$/ do |directory|%0a  check_directory_presence([directory], true)%0aend%0a%0aThen /^a directory named "([^"]*)" should not exist$/ do |directory|%0a  check_directory_presence([directory], false)%0aend%0a%0aThen /^the file "([^"]*)" should contain "([^"]*)"$/ do |file, partial_content|%0a  check_file_content(file, partial_content, true)%0aend%0a%0aThen /^the file "([^"]*)" should not contain "([^"]*)"$/ do |file, partial_content|%0a  check_file_content(file, partial_content, false)%0aend%0a%0aThen /^the file "([^"]*)" should contain:$/ do |file, partial_content|%0a  check_file_content(file, partial_content, true)%0aend%0a%0aThen /^the file "([^"]*)" should contain exactly:$/ do |file, exact_content|%0a  check_exact_file_content(file, exact_content)%0aend%0a%0aThen /^the file "([^"]*)" should match \/([^\/]*)\/$/ do |file, partial_content|%0a  check_file_content(file, /#{partial_content}/, true)%0aend%0a%0aThen /^the file "([^"]*)" should not match \/([^\/]*)\/$/ do |file, partial_content|%0a  check_file_content(file, /#{partial_content}/, false)%0aend%0a(:sourceend:)%0a %0a
time=1354180406
author:1354180406=tamara
csum:1354180406=new page
diff:1354180406:1354180406:=1,334d0%0a%3c >>comment%3c%3c%0a%3c Summary:aruba is a ruby gem that in conjunction with cucumber makes testing ruby command line applications much easier%0a%3c Parent:(Technology.)Ruby%0a%3c IncludeMe:[[(Technology.)Ruby]]%0a%3c Categories:[[!HowTos]]%0a%3c Tags: ruby, command line, testing, cucumber, aruba%0a%3c (:tags-hide ruby, command line, testing, cucumber, aruba :)%0a%3c >>%3c%3c%0a%3c %0a%3c [[#excerpt]]%0a%3c I have been trying to learn how to use aruba in testing a command line ruby application, as described in the [[methadone -> http://davetron5000.github.com/methadone/]] site. There seems to be little to go on out there. I was getting frustrated until I found out where the nifty steps are implmenented.%0a%3c [[#excerptend]]%0a%3c %0a%3c !! Aruba, and Cucumber%0a%3c %0a%3c [[Cucumber]] is a great feature testing tool for [[Ruby]] applications. It is used extensively in [[RubyOnRails]] web applications, and for many gems.%0a%3c %0a%3c I have started to write a command line application for work and started using the methadone gem, which makes things pretty sweet. It uses cucumber and [[Aruba -> https://github.com/cucumber/aruba]] to drive the cucumber feature tests.%0a%3c %0a%3c The problem was, I didn't know the step definitions, and couldn't figure out where they were. I finally, after much digging, discovered that under the gem's @@lib/aruba@@ directory, was a file called @@cucumber.rb@@ which, lo and behold, contained all the things I was looking for.%0a%3c %0a%3c Here is the set of defined steps from that [[file -> https://github.com/cucumber/aruba/blob/master/lib/aruba/cucumber.rb]]:%0a%3c %0a%3c (:source lang=text linenum -getcode:)%0a%3c Given /The default aruba timeout is (\d+) seconds/ do |seconds|%0a%3c   @aruba_timeout_seconds = seconds.to_i%0a%3c end%0a%3c %0a%3c Given /^I'm using a clean gemset "([^"]*)"$/ do |gemset|%0a%3c   use_clean_gemset(gemset)%0a%3c end%0a%3c %0a%3c Given /^a directory named "([^"]*)"$/ do |dir_name|%0a%3c   create_dir(dir_name)%0a%3c end%0a%3c %0a%3c Given /^a file named "([^"]*)" with:$/ do |file_name, file_content|%0a%3c   write_file(file_name, file_content)%0a%3c end%0a%3c %0a%3c Given /^a (\d+) byte file named "([^"]*)"$/ do |file_size, file_name|%0a%3c   write_fixed_size_file(file_name, file_size.to_i)%0a%3c end%0a%3c %0a%3c Given /^an empty file named "([^"]*)"$/ do |file_name|%0a%3c   write_file(file_name, "")%0a%3c end%0a%3c %0a%3c When /^I write to "([^"]*)" with:$/ do |file_name, file_content|%0a%3c   write_file(file_name, file_content)%0a%3c end%0a%3c %0a%3c When /^I overwrite "([^"]*)" with:$/ do |file_name, file_content|%0a%3c   overwrite_file(file_name, file_content)%0a%3c end%0a%3c %0a%3c When /^I append to "([^"]*)" with:$/ do |file_name, file_content|%0a%3c   append_to_file(file_name, file_content)%0a%3c end%0a%3c %0a%3c When /^I append to "([^"]*)" with "([^"]*)"$/ do |file_name, file_content|%0a%3c   append_to_file(file_name, file_content)%0a%3c end%0a%3c %0a%3c When /^I remove the file "([^"]*)"$/ do |file_name|%0a%3c   remove_file(file_name)%0a%3c end%0a%3c %0a%3c When /^I cd to "([^"]*)"$/ do |dir|%0a%3c   cd(dir)%0a%3c end%0a%3c %0a%3c When /^I run "(.*)"$/ do |cmd|%0a%3c   warn(%25{\e[35m    The /^I run "(.*)"$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a%3c   run_simple(unescape(cmd), false)%0a%3c end%0a%3c %0a%3c When /^I run `([^`]*)`$/ do |cmd|%0a%3c   run_simple(unescape(cmd), false)%0a%3c end%0a%3c %0a%3c When /^I successfully run "(.*)"$/ do |cmd|%0a%3c   warn(%25{\e[35m    The  /^I successfully run "(.*)"$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a%3c   run_simple(unescape(cmd))%0a%3c end%0a%3c %0a%3c ## I successfully run `echo -n "Hello"`%0a%3c ## I successfully run `sleep 29` for up to 30 seconds%0a%3c When /^I successfully run `(.*?)`(?: for up to (\d+) seconds)?$/ do |cmd, secs|%0a%3c   run_simple(unescape(cmd), true, secs && secs.to_i)%0a%3c end%0a%3c %0a%3c When /^I run "([^"]*)" interactively$/ do |cmd|%0a%3c   warn(%25{\e[35m    The /^I run "([^"]*)" interactively$/ step definition is deprecated. Please use the `backticks` version\e[0m})%0a%3c   run_interactive(unescape(cmd))%0a%3c end%0a%3c %0a%3c When /^I run `([^`]*)` interactively$/ do |cmd|%0a%3c   run_interactive(unescape(cmd))%0a%3c end%0a%3c %0a%3c When /^I type "([^"]*)"$/ do |input|%0a%3c   type(input)%0a%3c end%0a%3c %0a%3c When /^I wait for (?:output|stdout) to contain "([^"]*)"$/ do |expected|%0a%3c   Timeout::timeout(exit_timeout) do%0a%3c     loop do%0a%3c       break if assert_partial_output_interactive(expected)%0a%3c       sleep 0.1%0a%3c     end%0a%3c   end%0a%3c end%0a%3c %0a%3c Then /^the output should contain "([^"]*)"$/ do |expected|%0a%3c   assert_partial_output(expected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the output from "([^"]*)" should contain "([^"]*)"$/ do |cmd, expected|%0a%3c   assert_partial_output(expected, output_from(cmd))%0a%3c end%0a%3c %0a%3c Then /^the output from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a%3c   assert_no_partial_output(unexpected, output_from(cmd))%0a%3c end%0a%3c %0a%3c Then /^the output should not contain "([^"]*)"$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the output should contain:$/ do |expected|%0a%3c   assert_partial_output(expected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the output should not contain:$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_output)%0a%3c end%0a%3c %0a%3c ## the output should contain exactly "output"%0a%3c ## the output from `echo -n "Hello"` should contain exactly "Hello"%0a%3c Then /^the output(?: from "(.*?)")? should contain exactly "(.*?)"$/ do |cmd, expected|%0a%3c   assert_exact_output(expected, cmd ? output_from(cmd) : all_output)%0a%3c end%0a%3c %0a%3c ## the output should contain exactly:%0a%3c ## the output from `echo -n "Hello"` should contain exactly:%0a%3c Then /^the output(?: from "(.*?)")? should contain exactly:$/ do |cmd, expected|%0a%3c   assert_exact_output(expected, cmd ? output_from(cmd) : all_output)%0a%3c end%0a%3c %0a%3c # "the output should match" allows regex in the partial_output, if%0a%3c # you don't need regex, use "the output should contain" instead since%0a%3c # that way, you don't have to escape regex characters that%0a%3c # appear naturally in the output%0a%3c Then /^the output should match \/([^\/]*)\/$/ do |expected|%0a%3c   assert_matching_output(expected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the output should match:$/ do |expected|%0a%3c   assert_matching_output(expected, all_output)%0a%3c end%0a%3c %0a%3c # The previous two steps antagonists%0a%3c Then /^the output should not match \/([^\/]*)\/$/ do |expected|%0a%3c   assert_not_matching_output(expected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the output should not match:$/ do |expected|%0a%3c   assert_not_matching_output(expected, all_output)%0a%3c end%0a%3c %0a%3c Then /^the exit status should be (\d+)$/ do |exit_status|%0a%3c   assert_exit_status(exit_status.to_i)%0a%3c end%0a%3c %0a%3c Then /^the exit status should not be (\d+)$/ do |exit_status|%0a%3c   assert_not_exit_status(exit_status.to_i)%0a%3c end%0a%3c %0a%3c Then /^it should (pass|fail) with:$/ do |pass_fail, partial_output|%0a%3c   self.__send__("assert_#{pass_fail}ing_with", partial_output)%0a%3c end%0a%3c %0a%3c Then /^it should (pass|fail) with exactly:$/ do |pass_fail, exact_output|%0a%3c   assert_exit_status_and_output(pass_fail == "pass", exact_output, true)%0a%3c end%0a%3c %0a%3c Then /^it should (pass|fail) with regexp?:$/ do |pass_fail, expected|%0a%3c   assert_matching_output(expected, all_output)%0a%3c   assert_success(pass_fail == 'pass')%0a%3c end%0a%3c %0a%3c ## the stderr should contain "hello"%0a%3c ## the stderr from "echo -n 'Hello'" should contain "hello"%0a%3c ## the stderr should contain exactly:%0a%3c ## the stderr from "echo -n 'Hello'" should contain exactly:%0a%3c Then /^the stderr(?: from "(.*?)")? should contain( exactly)? "(.*?)"$/ do |cmd, exact, expected|%0a%3c   if exact%0a%3c     assert_exact_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a%3c   else%0a%3c     assert_partial_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a%3c   end%0a%3c end%0a%3c %0a%3c ## the stderr should contain:%0a%3c ## the stderr from "echo -n 'Hello'" should contain:%0a%3c ## the stderr should contain exactly:%0a%3c ## the stderr from "echo -n 'Hello'" should contain exactly:%0a%3c Then /^the stderr(?: from "(.*?)")? should contain( exactly)?:$/ do |cmd, exact, expected|%0a%3c   if exact%0a%3c     assert_exact_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a%3c   else%0a%3c     assert_partial_output(expected, cmd ? stderr_from(cmd) : all_stderr)%0a%3c   end%0a%3c end%0a%3c %0a%3c ## the stdout should contain "hello"%0a%3c ## the stdout from "echo -n 'Hello'" should contain "hello"%0a%3c ## the stdout should contain exactly:%0a%3c ## the stdout from "echo -n 'Hello'" should contain exactly:%0a%3c Then /^the stdout(?: from "(.*?)")? should contain( exactly)? "(.*?)"$/ do |cmd, exact, expected|%0a%3c   if exact%0a%3c     assert_exact_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a%3c   else%0a%3c     assert_partial_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a%3c   end%0a%3c end%0a%3c %0a%3c ## the stdout should contain:%0a%3c ## the stdout from "echo -n 'Hello'" should contain:%0a%3c ## the stdout should contain exactly:%0a%3c ## the stdout from "echo -n 'Hello'" should contain exactly:%0a%3c Then /^the stdout(?: from "(.*?)")? should contain( exactly)?:$/ do |cmd, exact, expected|%0a%3c   if exact%0a%3c     assert_exact_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a%3c   else%0a%3c     assert_partial_output(expected, cmd ? stdout_from(cmd) : all_stdout)%0a%3c   end%0a%3c end%0a%3c %0a%3c Then /^the stderr should not contain "([^"]*)"$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_stderr)%0a%3c end%0a%3c %0a%3c Then /^the stderr should not contain:$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_stderr)%0a%3c end%0a%3c %0a%3c Then /^the (stderr|stdout) should not contain anything$/ do |stream_name|%0a%3c   stream = self.send("all_#{stream_name}")%0a%3c   stream.should be_empty%0a%3c end%0a%3c %0a%3c Then /^the stdout should not contain "([^"]*)"$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_stdout)%0a%3c end%0a%3c %0a%3c Then /^the stdout should not contain:$/ do |unexpected|%0a%3c   assert_no_partial_output(unexpected, all_stdout)%0a%3c end%0a%3c %0a%3c Then /^the stdout from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a%3c   assert_no_partial_output(unexpected, stdout_from(cmd))%0a%3c end%0a%3c %0a%3c Then /^the stderr from "([^"]*)" should not contain "([^"]*)"$/ do |cmd, unexpected|%0a%3c   assert_no_partial_output(unexpected, stderr_from(cmd))%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should not exist$/ do |file_name|%0a%3c   check_file_presence([file_name], false)%0a%3c end%0a%3c %0a%3c Then /^the following files should exist:$/ do |files|%0a%3c   check_file_presence(files.raw.map{|file_row| file_row[0]}, true)%0a%3c end%0a%3c %0a%3c Then /^the following files should not exist:$/ do |files|%0a%3c   check_file_presence(files.raw.map{|file_row| file_row[0]}, false)%0a%3c end%0a%3c %0a%3c Then /^a file named "([^"]*)" should exist$/ do |file|%0a%3c   check_file_presence([file], true)%0a%3c end%0a%3c %0a%3c Then /^a file named "([^"]*)" should not exist$/ do |file|%0a%3c   check_file_presence([file], false)%0a%3c end%0a%3c %0a%3c Then /^a (\d+) byte file named "([^"]*)" should exist$/ do |file_size, file_name|%0a%3c   check_file_size([[file_name, file_size.to_i]])%0a%3c end%0a%3c %0a%3c Then /^the following directories should exist:$/ do |directories|%0a%3c   check_directory_presence(directories.raw.map{|directory_row| directory_row[0]}, true)%0a%3c end%0a%3c %0a%3c Then /^the following directories should not exist:$/ do |directories|%0a%3c   check_directory_presence(directories.raw.map{|directory_row| directory_row[0]}, false)%0a%3c end%0a%3c %0a%3c Then /^a directory named "([^"]*)" should exist$/ do |directory|%0a%3c   check_directory_presence([directory], true)%0a%3c end%0a%3c %0a%3c Then /^a directory named "([^"]*)" should not exist$/ do |directory|%0a%3c   check_directory_presence([directory], false)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should contain "([^"]*)"$/ do |file, partial_content|%0a%3c   check_file_content(file, partial_content, true)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should not contain "([^"]*)"$/ do |file, partial_content|%0a%3c   check_file_content(file, partial_content, false)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should contain:$/ do |file, partial_content|%0a%3c   check_file_content(file, partial_content, true)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should contain exactly:$/ do |file, exact_content|%0a%3c   check_exact_file_content(file, exact_content)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should match \/([^\/]*)\/$/ do |file, partial_content|%0a%3c   check_file_content(file, /#{partial_content}/, true)%0a%3c end%0a%3c %0a%3c Then /^the file "([^"]*)" should not match \/([^\/]*)\/$/ do |file, partial_content|%0a%3c   check_file_content(file, /#{partial_content}/, false)%0a%3c end%0a%3c (:sourceend:)%0a%3c  %0a
host:1354180406=71.63.215.130
