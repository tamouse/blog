version=pmwiki-2.2.36 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.79 Safari/535.11
author=tamara
charset=ISO-8859-1
csum=change TODO from indent to ** to keep ol list from starting over
ctime=1288651664
host=71.63.211.0
name=Technology.FlexibleQueryFunctions
rev=6
targets=Technology.FlexibleQueryFunctions,Technology.BeModular,Technology.WriteFunctionsInASeparateInclude,Technology.BestPracticeForBuildingSQLQueries,Profiles.Tamara,Technology.PHP,Technology.IncludeMe,Category.BestPractices,Category.Articles
text=[[#excerpt]]%0aAlong with [[BeModular|modularity]] and [[WriteFunctionsInASeparateInclude|reusable libraries]], making functions flexible is a helpful thing in making functions more reusable. PHP has a rich feature set that makes creating flexible and useful functions a reality. While is does add some structural complexity sometimes, it is often worth it in terms of only coding what is necessary for a particular application, rather than redoing things over again that you've done 1000 times before.%0a[[#excerptend]]%0a%0a(See also: BestPracticeForBuildingSQLQueries:)%0a%0a%0a!!Flexible functions%0a%0aOne way to achieve flexibility in functions is to pass in options that can be used to modify and extend the behaviour of the function. (Note: this is a purely procedural discussion. OOP allows other ways of extending functions and should be encouraged as well.)%0a%0aOne such way is to optionally pass an array into the function, that is set up as an associative array with keys indicating parts to modify and values the ways to modify the function. One such function that lends itself well to this is an SQL SELECT query function.%0a%0aIn my @@[[WriteFunctionsInASeparateInclude|functions.inc.php]]@@ file, I have defined such a flexible function: @@get_all_array()@@, which takes nominally the data base descriptor (in this case, a mysqli database descriptor object), a table specification, and an optional argument of options to possibly modify the query. Here is is:%0a%0a(:source lang=php linenum tabwidth=4 header="function get_all_array":)%0a/**%0a * Get All records from a table, returning them %0a * in an indexed array of records as associative arrays%0a *%0a *  $db and $tblname are a required paramters%0a *%0a * This function supports an array of options that may be %0a * used to customize the sql query.%0a *  $options= array(%0a *    'columns'=>scalar column specification or %0a                            array('column1','column2','column3'...),%0a *    'where'=>scalar where clause or  %0a *                      array('where clause1','where clause2',...),%0a *    'sort'=>scalar sort clause or %0a *                 array('sort clause1','sort clause2',...)%0a *                 )%0a *%0a * If any of these are omitted (and they're all optional), %0a * the following behaviour is used:%0a *    if columns is empty or missing, use "*" as the %0a *      column selector%0a *    if sort is empty or missing, don't do any ordering %0a *      of the records on retrieval%0a *    if where is empty or missing, don't provide any %0a *     selection criteria%0a *%0a * Thus, calling get_all_array($db,TABLENAME) %0a * will return all rows of the table specified by TABLENAME%0a *%0a * This function uses mysqli object oriented calls. %0a * The database descriptor is passed in $db.%0a *%0a **/%0afunction get_all_array($db,$tblname,$options=NULL)%0a{%0a	if (isset($options)) {%0a		if (!is_array($options)) return FALSE; // options MUST be an array%0a		// ensure each part of options is actually an array%0a		foreach ($options as $key => $value) {%0a			switch ($key) {%0a				case 'columns':%0a					if (is_array($value)) {%0a						$columns = $value;%0a					} else {%0a						$columns[] = $value;%0a					}%0a					break;%0a				case 'sort':%0a					if (is_array($value)) {%0a						$orderparts = $value;%0a					} else {%0a						$orderparts[] = $value;%0a					}%0a					break;%0a				%0a				case 'where':%0a					if (is_array($value)) {%0a						$whereparts = $value;%0a					} else {%0a						$whereparts[] = $value;%0a					}%0a					break;%0a					%0a				default:%0a					# code...%0a					break;%0a			}%0a		}%0a	}%0a	%0a	$sql_a = Array(); /* initialize the sql query */%0a	$sql_a[] = "SELECT";%0a	$sql_a[] = (!empty($columns) ? join(", ",$columns) : "*");%0a	$sql_a[] = "FROM $tblname";%0a	if (!empty($whereparts)) $sql_a[] = " WHERE ".join(" AND ",$whereparts);%0a	if (!empty($orderparts)) $sql_a[] = " ORDER BY ".join(",",$orderparts);%0a	$sql_s = join(" ",$sql_a);%0a	$result=$db->query($sql_s);%0a	if ($result === FALSE) return FALSE; // you may want to do something more here, such as showing an error, etc%0a	$all_rows = Array();%0a	if ($result->num_rows > 0) {%0a		if (method_exists('mysqli_result','fetch_all')) {%0a			$all_rows = $result->fetch_all(MYSQLI_ASSOC);%0a		} else {%0a			/* version is too old, have to do it by hand */%0a			while ($row = $result->fetch_assoc()) {%0a				$all_rows[] = $row;%0a			}%0a		}%0a	}%0a	$result->free();%0a	return $all_rows;%0a}%0a(:sourceend:)%0a%0aThere are several things to note here.%0a%0a# the options parameter defaults to NULL -- if nothing gets passed in then there will be nothing to modify the function -- this is good, because it allows a default behaviour to be defined. Including the assignment in the parameter list means PHP won't squawk if this parameter is omitted.%0a%0a# The database descriptor is passed in. This means the function doesn't have to rely on any globals being defined other than a few constants.%0a%0a# The options processing is flexible. If the value of any particular array item is a scalar, it is turned into an array item. Otherwise the value is assigned to the modifier array (in this case: columns, whereparts, orderparts).%0a%0a# This still isn't fully defensive in that the options structure may be made more complicated than expected, which will cause the eventual sql statement to fail. Given that this is solely a SELECT statement, there should be no data corruption possible with this.%0a%0a** TODO: make this work with prepared statements. [[~tamara]] March 21, 2012, at 01:29 AM%0a%0a# The function makes use of the  BestPracticeForBuildingSQLQueries by building each element of the SELECT statement as an array item and then joining the array elements together to form the eventual string that gets passed to the mysqli query method.%0a%0a# The one option that doesn't follow the BestPracticeForBuildingSQLQueries is the @@$tblname@@. I chose that because it isn't often that I find myself with complicated joins, etc, and most often with just a single table name. However, this is a possible enhancement for the future. @@$tblname@@ could be a scalar or an array, much like the choices in the options parameter. More complicated table specifications can still be made by simply assigning a string of them to the @@$tblname@@ parameter, such as @@"customers as c, orders as o, deliveries as d"@@. Ideally, I think I would want to represent that as an array rather than a single string:%0a%0a(:source lang=php linenum:)%0a$tblspec = array(%0a    "customers as c",%0a    "orders as o",%0a    "deliveries as d"%0a    );%0a(:sourceend:)%0a%0a->Then the array could be joined into the sql array in the function.%0a%0a>>comment%3c%3c%0aSummary:How to create flexible, reusable query functions%0aParent:(Technology.)PHP%0aIncludeMe:[[Technology.PHP]]%0aCategories:[[!BestPractices]],[[!Articles]]%0aTags: php, reuse, best practices, modularity, reuse%0a(:tags-hide php, reuse, best practices, modularity, reuse :)%0a>>%3c%3c%0a%0a%0a
time=1332311637
author:1332311637=tamara
csum:1332311637=change TODO from indent to ** to keep ol list from starting over
diff:1332311637:1332311518:=122c122%0a%3c ** TODO: make this work with prepared statements. [[~tamara]] March 21, 2012, at 01:29 AM%0a---%0a> -> TODO: make this work with prepared statements. [[~tamara]] March 21, 2012, at 01:29 AM%0a
host:1332311637=71.63.211.0
author:1332311518=tamara
csum:1332311518=change parent to php
diff:1332311518:1332311364:=140,141c140,141%0a%3c Parent:(Technology.)PHP%0a%3c IncludeMe:[[Technology.PHP]]%0a---%0a> Parent:(Technology.)Development%0a> IncludeMe:[[Technology.Development]]%0a
host:1332311518=71.63.211.0
author:1332311364=tamara
csum:1332311364=clean up
diff:1332311364:1332310153:=1c1,9%0a%3c [[#excerpt]]%0a---%0a> (:Summary:How to create flexible, reusable query functions:)%0a> [[%3c%3c]]%0a> %3c%3c|SoftwareAndWebProgramming|>>\\%0a> %3c%3c|[[PHP]]|>>%0a> %0a> '''Tags:''' (:tags php, reuse, best practices, coding examples, source code, web development:)%0a> %0a> (See also: BestPracticeForBuildingSQLQueries:)%0a> %0a3,7c11%0a%3c [[#excerptend]]%0a%3c %0a%3c (See also: BestPracticeForBuildingSQLQueries:)%0a%3c %0a%3c %0a---%0a> %0a16c20%0a%3c (:source lang=php linenum tabwidth=4 header="function get_all_array":)%0a---%0a> (:source lang=php linenum tabwidth=4:)%0a48a53,54%0a>  * @return indexed array of records as associative arrays%0a>  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a53,54c59%0a%3c 		if (!is_array($options)) return FALSE; // options MUST be an array%0a%3c 		// ensure each part of options is actually an array%0a---%0a> 		debug_var(__FUNCTION__." \$options:",$options);%0a93a99%0a> 	debug(__FUNCTION__." \$sql_s=$sql_s");%0a95c101%0a%3c 	if ($result === FALSE) return FALSE; // you may want to do something more here, such as showing an error, etc%0a---%0a> 	if ($result === FALSE) emit_fatal_error(APP_NAME." in ".__FILE__."@".__LINE__." "."SQL Query Failure. \$sql_s=$sql_s. error=".$db->error);%0a101c107%0a%3c 			/* version is too old, have to do it by hand */%0a---%0a> 			/* vesion is too old, have to do it by hand */%0a122,123d127%0a%3c -> TODO: make this work with prepared statements. [[~tamara]] March 21, 2012, at 01:29 AM%0a%3c %0a138,147c142,147%0a%3c >>comment%3c%3c%0a%3c Summary:How to create flexible, reusable query functions%0a%3c Parent:(Technology.)Development%0a%3c IncludeMe:[[Technology.Development]]%0a%3c Categories:[[!BestPractices]],[[!Articles]]%0a%3c Tags: php, reuse, best practices, modularity, reuse%0a%3c (:tags-hide php, reuse, best practices, modularity, reuse :)%0a%3c >>%3c%3c%0a%3c %0a%3c %0a---%0a> %0a> %0a> %0a> %0a> %0a> %25rframe%25 '''Categories:''' [[!ComputerStuff]]%0a
host:1332311364=71.63.211.0
author:1332310153=tamara
csum:1332310153=Page moved to Technology.FlexibleQueryFunctions from Main.FlexibleQueryFunctions
diff:1332310153:1289639318:=
host:1332310153=71.63.211.0
author:1289639318=tamara
csum:1289639318=change extension from .inc to .php
diff:1289639318:1288651664:minor=18,19c18,19%0a%3c In my @@[[WriteFunctionsInASeparateInclude|functions.inc.php]]@@ file, I have defined such a flexible function: @@get_all_array()@@, which takes nominally the data base descriptor (in this case, a mysqli database descriptor object), a table specification, and an optional argument of options to possibly modify the query. Here is is:%0a%3c %0a---%0a> In my @@[[WriteFunctionsInASeparateInclude|functions.inc]]@@ file, I have defined such a flexible function: @@get_all_array()@@, which takes nominally the data base descriptor (in this case, a mysqli database descriptor object), a table specification, and an optional argument of options to possibly modify the query. Here is is:%0a> %0a99c99%0a%3c 	debug(__FUNCTION__." \$sql_s=$sql_s");%0a---%0a> 	debug("get_all_array \$sql_s=$sql_s");%0a
host:1289639318=71.63.211.0
author:1288651664=tamara
diff:1288651664:1288651664:=1,147d0%0a%3c (:Summary:How to create flexible, reusable query functions:)%0a%3c [[%3c%3c]]%0a%3c %3c%3c|SoftwareAndWebProgramming|>>\\%0a%3c %3c%3c|[[PHP]]|>>%0a%3c %0a%3c '''Tags:''' (:tags php, reuse, best practices, coding examples, source code, web development:)%0a%3c %0a%3c (See also: BestPracticeForBuildingSQLQueries:)%0a%3c %0a%3c Along with [[BeModular|modularity]] and [[WriteFunctionsInASeparateInclude|reusable libraries]], making functions flexible is a helpful thing in making functions more reusable. PHP has a rich feature set that makes creating flexible and useful functions a reality. While is does add some structural complexity sometimes, it is often worth it in terms of only coding what is necessary for a particular application, rather than redoing things over again that you've done 1000 times before.%0a%3c %0a%3c !!Flexible functions%0a%3c %0a%3c One way to achieve flexibility in functions is to pass in options that can be used to modify and extend the behaviour of the function. (Note: this is a purely procedural discussion. OOP allows other ways of extending functions and should be encouraged as well.)%0a%3c %0a%3c One such way is to optionally pass an array into the function, that is set up as an associative array with keys indicating parts to modify and values the ways to modify the function. One such function that lends itself well to this is an SQL SELECT query function.%0a%3c %0a%3c In my @@[[WriteFunctionsInASeparateInclude|functions.inc]]@@ file, I have defined such a flexible function: @@get_all_array()@@, which takes nominally the data base descriptor (in this case, a mysqli database descriptor object), a table specification, and an optional argument of options to possibly modify the query. Here is is:%0a%3c %0a%3c (:source lang=php linenum tabwidth=4:)%0a%3c /**%0a%3c  * Get All records from a table, returning them %0a%3c  * in an indexed array of records as associative arrays%0a%3c  *%0a%3c  *  $db and $tblname are a required paramters%0a%3c  *%0a%3c  * This function supports an array of options that may be %0a%3c  * used to customize the sql query.%0a%3c  *  $options= array(%0a%3c  *    'columns'=>scalar column specification or %0a%3c                             array('column1','column2','column3'...),%0a%3c  *    'where'=>scalar where clause or  %0a%3c  *                      array('where clause1','where clause2',...),%0a%3c  *    'sort'=>scalar sort clause or %0a%3c  *                 array('sort clause1','sort clause2',...)%0a%3c  *                 )%0a%3c  *%0a%3c  * If any of these are omitted (and they're all optional), %0a%3c  * the following behaviour is used:%0a%3c  *    if columns is empty or missing, use "*" as the %0a%3c  *      column selector%0a%3c  *    if sort is empty or missing, don't do any ordering %0a%3c  *      of the records on retrieval%0a%3c  *    if where is empty or missing, don't provide any %0a%3c  *     selection criteria%0a%3c  *%0a%3c  * Thus, calling get_all_array($db,TABLENAME) %0a%3c  * will return all rows of the table specified by TABLENAME%0a%3c  *%0a%3c  * This function uses mysqli object oriented calls. %0a%3c  * The database descriptor is passed in $db.%0a%3c  *%0a%3c  * @return indexed array of records as associative arrays%0a%3c  * @author Tamara Temple %3ctamara@tamaratemple.com>%0a%3c  **/%0a%3c function get_all_array($db,$tblname,$options=NULL)%0a%3c {%0a%3c 	if (isset($options)) {%0a%3c 		debug_var(__FUNCTION__." \$options:",$options);%0a%3c 		foreach ($options as $key => $value) {%0a%3c 			switch ($key) {%0a%3c 				case 'columns':%0a%3c 					if (is_array($value)) {%0a%3c 						$columns = $value;%0a%3c 					} else {%0a%3c 						$columns[] = $value;%0a%3c 					}%0a%3c 					break;%0a%3c 				case 'sort':%0a%3c 					if (is_array($value)) {%0a%3c 						$orderparts = $value;%0a%3c 					} else {%0a%3c 						$orderparts[] = $value;%0a%3c 					}%0a%3c 					break;%0a%3c 				%0a%3c 				case 'where':%0a%3c 					if (is_array($value)) {%0a%3c 						$whereparts = $value;%0a%3c 					} else {%0a%3c 						$whereparts[] = $value;%0a%3c 					}%0a%3c 					break;%0a%3c 					%0a%3c 				default:%0a%3c 					# code...%0a%3c 					break;%0a%3c 			}%0a%3c 		}%0a%3c 	}%0a%3c 	%0a%3c 	$sql_a = Array(); /* initialize the sql query */%0a%3c 	$sql_a[] = "SELECT";%0a%3c 	$sql_a[] = (!empty($columns) ? join(", ",$columns) : "*");%0a%3c 	$sql_a[] = "FROM $tblname";%0a%3c 	if (!empty($whereparts)) $sql_a[] = " WHERE ".join(" AND ",$whereparts);%0a%3c 	if (!empty($orderparts)) $sql_a[] = " ORDER BY ".join(",",$orderparts);%0a%3c 	$sql_s = join(" ",$sql_a);%0a%3c 	debug("get_all_array \$sql_s=$sql_s");%0a%3c 	$result=$db->query($sql_s);%0a%3c 	if ($result === FALSE) emit_fatal_error(APP_NAME." in ".__FILE__."@".__LINE__." "."SQL Query Failure. \$sql_s=$sql_s. error=".$db->error);%0a%3c 	$all_rows = Array();%0a%3c 	if ($result->num_rows > 0) {%0a%3c 		if (method_exists('mysqli_result','fetch_all')) {%0a%3c 			$all_rows = $result->fetch_all(MYSQLI_ASSOC);%0a%3c 		} else {%0a%3c 			/* vesion is too old, have to do it by hand */%0a%3c 			while ($row = $result->fetch_assoc()) {%0a%3c 				$all_rows[] = $row;%0a%3c 			}%0a%3c 		}%0a%3c 	}%0a%3c 	$result->free();%0a%3c 	return $all_rows;%0a%3c }%0a%3c (:sourceend:)%0a%3c %0a%3c There are several things to note here.%0a%3c %0a%3c # the options parameter defaults to NULL -- if nothing gets passed in then there will be nothing to modify the function -- this is good, because it allows a default behaviour to be defined. Including the assignment in the parameter list means PHP won't squawk if this parameter is omitted.%0a%3c %0a%3c # The database descriptor is passed in. This means the function doesn't have to rely on any globals being defined other than a few constants.%0a%3c %0a%3c # The options processing is flexible. If the value of any particular array item is a scalar, it is turned into an array item. Otherwise the value is assigned to the modifier array (in this case: columns, whereparts, orderparts).%0a%3c %0a%3c # This still isn't fully defensive in that the options structure may be made more complicated than expected, which will cause the eventual sql statement to fail. Given that this is solely a SELECT statement, there should be no data corruption possible with this.%0a%3c %0a%3c # The function makes use of the  BestPracticeForBuildingSQLQueries by building each element of the SELECT statement as an array item and then joining the array elements together to form the eventual string that gets passed to the mysqli query method.%0a%3c %0a%3c # The one option that doesn't follow the BestPracticeForBuildingSQLQueries is the @@$tblname@@. I chose that because it isn't often that I find myself with complicated joins, etc, and most often with just a single table name. However, this is a possible enhancement for the future. @@$tblname@@ could be a scalar or an array, much like the choices in the options parameter. More complicated table specifications can still be made by simply assigning a string of them to the @@$tblname@@ parameter, such as @@"customers as c, orders as o, deliveries as d"@@. Ideally, I think I would want to represent that as an array rather than a single string:%0a%3c %0a%3c (:source lang=php linenum:)%0a%3c $tblspec = array(%0a%3c     "customers as c",%0a%3c     "orders as o",%0a%3c     "deliveries as d"%0a%3c     );%0a%3c (:sourceend:)%0a%3c %0a%3c ->Then the array could be joined into the sql array in the function.%0a%3c %0a%3c %0a%3c %0a%3c %0a%3c %0a%3c %0a%3c %25rframe%25 '''Categories:''' [[!ComputerStuff]]%0a
host:1288651664=71.63.211.0
