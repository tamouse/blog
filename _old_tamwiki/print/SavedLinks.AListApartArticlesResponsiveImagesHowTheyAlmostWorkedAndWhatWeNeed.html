<!DOCTYPE html>
<html><head>
  <title>TamWiki | SavedLinks / A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need</title>
  <link rel='stylesheet' href='http://wiki.tamouse.org/pub/skins/print/print.css' type='text/css' />
</head>
<body>
<!--PageText-->
<div id='wikitext'>
<p class='vspace'>Link: <a class='external' href='http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/' target='_blank'>A List Apart: Articles: Responsive Images: How they Almost Worked and What We Need</a>
</p>
<p class='vspace'>by <a class='external' href='http://www.alistapart.com/authors/m/matmarquis' target='_blank'>Mat Marquis</a>
<br  />published: January 31, 2012
</p>
<div class='vspace'></div><div class='round lrindent quote' > 
<p>So, now what?
</p>
<p class='vspace'>Long after the Boston Globe site launched, we continued to iterate on our approach. Jason Grigsby has done an incredible job documenting the details of those trials and tribulations in a series of blog posts.
</p>
<p class='vspace'>This brings us to the present day, with some of the brightest minds on the web looking for something &mdash; anything &mdash; that will get the job done. Some think that it isn't a solvable problem right now, and are placing their bets on user agent detection as a temporary solution. While this is a perfectly viable answer in the short term, I maintain that it's untenable going forward: with the ever-expanding range of mobile phones and tablets in circulation, we could never hope to maintain a reasonable list of browsers and devices for long.
</p>
<p class='vspace'>I believe that the ultimate solution shouldn't hinge on scripting or CSS &mdash; and certainly nothing like UA detection, cookies, custom scripting on the front end, or any server-side shenanigans. Our aim is to represent and serve content appropriately, and for that reason I believe that this should be solved in markup.
</p>
<p class='vspace'>The img tag isn't going to cut it for this, though. It's effective at conveying the hilarious antics of house cats, but it isn't well suited to complex logic. It does one thing, and it does it well: it takes a single image source, and it puts it on your screen. If we were to modify this behavior at the browser level, we would never be able to guarantee our changes wouldn't introduce issues in older browsers. We also know from experience that img doesn't leave us much (if any) room to polyfill this new behavior.
</p>
<p class='vspace'>What we need is a new markup pattern &mdash; one that allows us to specify multiple source files, but still specify universally-recognized markup as  "fallback content" browsers that don't recognize the new tag. This should sound familiar, as this pattern already exists: the video and audio tags.
</p>
<p class='vspace'>We know that a video tag can contain references to multiple sources, and that we can specify fallback content within the tag that's only visible to browsers that don't support video natively &mdash; usually a Flash-based video. What you may not know is that there's already a way to use media queries to determine which video source to use, though browser support is a little spotty.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock1'>
  <div class='sourceblocktext'><div class="html4strict"><span class="sc2">&lt;video&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;source <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;high-res.webm&quot;</span> <span class="kw3">media</span><span class="sy0">=</span><span class="st0">&quot;min-width:800px&quot;</span> <span class="sy0">/</span>&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;source <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;low-res.webm&quot;</span> <span class="sy0">/</span>&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;<span class="kw2">img</span> <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;poster.jpg&quot;</span> <span class="sy0">/</span>&gt;</span><br />
<span class="sc2">&lt;<span class="sy0">/</span>video&gt;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'>From there, it doesn't take much imagination to see how we could use a pattern like this.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock2'>
  <div class='sourceblocktext'><div class="html4strict"><span class="sc2">&lt;picture&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;source <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;high-res.jpg&quot;</span> <span class="kw3">media</span><span class="sy0">=</span><span class="st0">&quot;min-width: 800px&quot;</span> <span class="sy0">/</span>&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;source <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;mobile.jpg&quot;</span> <span class="sy0">/</span>&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc-1">&lt;!-- Fallback content: --&gt;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc2">&lt;<span class="kw2">img</span> <span class="kw3">src</span><span class="sy0">=</span><span class="st0">&quot;mobile.jpg&quot;</span> <span class="sy0">/</span>&gt;</span><br />
<span class="sc2">&lt;<span class="sy0">/</span>picture&gt;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'>We could have a limitless number of options by using source media queries &mdash; higher resolution images for high-res displays over a certain size, for example. If we could reliably detect connection speed, one day we may be able to add <code class='escaped'>media="connection-speed: edge"</code> or <code class='escaped'>media="min-speed: 200kbps"</code> to our source elements. If these source elements are implemented per the <span class='wikiword'>HTML5</span> spec, a request will only be sent for the ones that match our media query. What we get is a single, highly-tailored request, with conditional flexibility limited only by a constantly growing roster of media queries.
</p>
<p class='vspace'>Once we've established that markup as our foundation, we may be able to polyfill the expected behavior for browsers that don't yet support it. While it's likely that the polyfills would still involve more than one request, starting with a tried-and-true fallback pattern would allow us to apply polyfills at our discretion.
</p></div>
<p class='vspace'>Saved date: 2012-2-26 14:36
</p>
<div class='vspace'></div>
</div>

</body>
</html>
